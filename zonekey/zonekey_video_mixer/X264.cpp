#include "X264.h"
#include <cc++/socket.h>
#include <assert.h>

/** 
A qualitative overview of x264's ratecontrol methods
By Loren Merritt

Historical note:
This document is outdated, but a significant part of it is still accurate.  Here are some important ways
     ratecontrol has changed since the authoring of this document:
- By default, MB-tree is used instead of qcomp for weighting frame quality based on complexity.  MB-tree 
   is effectively a generalization of qcomp to the macroblock level. MB-tree also replaces the constant 
   offsets for B-frame quantizers.  The legacy algorithm is still available for low-latency applications.
- Adaptive quantization is now used to distribute quality among each frame; frames are no longer constant
   quantizer, even if MB-tree is off.
- VBV runs per-row rather than per-frame to improve accuracy.

x264's ratecontrol is based on libavcodec's, and is mostly empirical. But I can retroactively propose the 
   following theoretical points which underlie most of the algorithms:

- You want the movie to be somewhere approaching constant quality. However, constant quality does not
   mean constant PSNR nor constant QP. Details are less noticeable in 
   high-complexity or high-motion scenes, so you can get away with somewhat higher QP for the same perceived quality.
- On the other hand, you get more quality per bit if you spend those bits in scenes where motion 
   compensation works well: A given artifact may stick around several seconds in a low-motion scene, and
   you only have to fix it in one frame to improve the quality of the whole scene.
- Both of the above are correlated with the number of bits it takes to encode a frame at a given QP.
- Given one encoding of a frame, we can predict the number of bits needed to encode it at a different QP. 
   This prediction gets less accurate if the QPs are far apart.
- The importance of a frame depends on the number of other frames that are predicted from it. Hence I-frames 
  get reduced QP depending on the number and complexity of following inter-frames, disposable B-frames get higher
  QP than P-frames, and referenced B-frames are between P-frames and disposable B-frames.


The modes:

    2pass:
Given some data about each frame of a 1st pass (e.g. generated by 1pass ABR, below), we try to choose QPs to
  maximize quality while matching a specified total size. This is separated into 3 parts:
(1) Before starting the 2nd pass, select the relative number of bits to allocate between frames. This pays 
    no attention to the total size of the encode. The default formula, empirically selected to balance between
	the 1st 2 theoretical points, is "complexity ** 0.6", where complexity is defined to be the bit size of 
	the frame at a constant QP (estimated from the 1st pass).
(2) Scale the results of (1) to fill the requested total size. Optional: Impose VBV limitations. Due to 
     nonlinearities in the frame size predictor and in VBV, this is an iterative process.
(3) Now start encoding. After each frame, update future QPs to compensate for mispredictions in size. 
     If the 2nd pass is consistently off from the predicted size (usually because we use slower compression
	 options than the 1st pass), then we multiply all future frames' qscales by the reciprocal of the error.
	 Additionally, there is a short-term compensation to prevent us from deviating too far from the desired 
	 size near the beginning (when we don't have much data for the global compensation) and near the end (when 
	 global doesn't have time to react).

    1pass, average bitrate:
The goal is the same as in 2pass, but here we don't have the benefit of a previous encode, so all ratecontrol 
	must be done during the encode.
(1) This is the same as in 2pass, except that instead of estimating complexity from a previous encode, we run a
	fast motion estimation algo over a half-resolution version of the frame, and use the SATD residuals (these
	are also used in the decision between P- and B-frames). Also, we don't know the size or complexity of the 
	following GOP, so I-frame bonus is based on the past.
(2) We don't know the complexities of future frames, so we can only scale based on the past. The scaling factor 
	is chosen to be the one that would have resulted in the desired bitrate if it had been applied to all frames so far.
(3) Overflow compensation is the same as in 2pass. By tuning the strength of compensation, you can get anywhere 
	from near the quality of 2pass (but unpredictable size, like +- 10%) to reasonably strict filesize but lower quality.

    1pass, constant bitrate (VBV compliant):
(1) Same as ABR.
(2) Scaling factor is based on a local average (dependent on VBV buffer size) instead of all past frames.
(3) Overflow compensation is stricter, and has an additional term to hard limit the QPs if the VBV is near empty.
	Note that no hard limit is done for a full VBV, so CBR may use somewhat less than the requested bitrate. 
	Note also that if a frame violates VBV constraints despite the best efforts of prediction, it is not re-encoded.

    1pass, constant ratefactor:
(1) Same as ABR.
(2) The scaling factor is a constant based on the --crf argument.
(3) No overflow compensation is done.

    constant quantizer:
	QPs are simply based on frame type.

*/

// 从 annex b 流中，查找下一个 startcode，可能是 00 00 00 01 或者 00 00 01
// from  libavformat/avc.c
static const uint8_t *ff_avc_find_startcode_internal(const uint8_t *p, const uint8_t *end)
{
    const uint8_t *a = p + 4 - ((intptr_t)p & 3);

    for (end -= 3; p < a && p < end; p++) {
        if (p[0] == 0 && p[1] == 0 && p[2] == 1)
            return p;
    }

    for (end -= 3; p < end; p += 4) {
        uint32_t x = *(const uint32_t*)p;
        if ((x - 0x01010101) & (~x) & 0x80808080) { // generic
            if (p[1] == 0) {
                if (p[0] == 0 && p[2] == 1)
                    return p;
                if (p[2] == 0 && p[3] == 1)
                    return p+1;
            }
            if (p[3] == 0) {
                if (p[2] == 0 && p[4] == 1)
                    return p+2;
                if (p[4] == 0 && p[5] == 1)
                    return p+3;
            }
        }
    }

    for (end += 3; p < end; p++) {
        if (p[0] == 0 && p[1] == 0 && p[2] == 1)
            return p;
    }

    return end + 3;
}

/** 从 00 00 00 01 67 .... 的 h264 流，转换为 MSQueue
	保留 sps, pps ...
 */
static MSQueue *annexb2queue(const void *data, int len)
{
	MSQueue *queue = (MSQueue *)ms_new(MSQueue, 1);

	const unsigned char *head = (unsigned char*)data;
	const unsigned char *tail = head + len;
	const unsigned char *nal_start = ff_avc_find_startcode_internal(head, tail);
	const unsigned char *nal_end;
	mblk_t *nal;

	ms_queue_init(queue);

	for (;; ) {
		while (nal_start < tail && !*(nal_start++));
		if (nal_start == tail)
			break;

		nal_end = ff_avc_find_startcode_internal(nal_start, tail);

		// 此时 nal_start --> nal_end
		nal = allocb(nal_end - nal_start + 10, 0);	// 多分配了10个字节.
		memcpy(nal->b_wptr, nal_start, nal_end - nal_start);
		nal->b_wptr += nal_end - nal_start;

		// 将 mblk 添加到 queue 中.
		ms_queue_put(queue, nal);
		
		// 下一个
		nal_start = nal_end;
	}

	return queue;
}

X264::X264(X264Cfg *cfg)
	: cfg_(*cfg)
	, x264_(0)
	, next_pts_(0)
{
	force_key_ = true;	// 第一帧

	packer_ = rfc3984_new();
	rfc3984_set_mode(packer_, 1);

	x264_param_t param;
	x264_param_default_preset(&param, "veryfast", "zerolatency");

	param.i_threads = 0;	// 

	param.i_width = cfg->width;
	param.i_height = cfg->height;

	//param.i_nal_hrd = X264_NAL_HRD_CBR;

	// gop size
	param.i_keyint_max = cfg->gop;
	//param.i_keyint_min = 25;

	// fps
	param.i_fps_den = param.i_timebase_den = 1;
	param.i_fps_num = param.i_timebase_num = (int)cfg->fps;
	
	// max slize size
	// FIXME：libavcodec 中，h264 解码器的 MAX_SLICES 设置为 16，所以，看起来，这个不能设置的太小
	// 相应的，将 libavcodec 中的 h264.h 中的 MAX_SLICES 从 16 改为 1024 了，一半的，估计一个关键帧不会大于 1.5M 吧，天晓得 :)
	param.i_slice_max_size = ms_get_payload_max_size();
	//param.i_slice_count = 16;

	param.b_repeat_headers = 1;	// 需要重复 sps/pps...
	param.b_annexb = 0;			// 便于 rfc3984处理

	//these parameters must be set so that our stream is baseline
	//param.analyse.b_transform_8x8 = 0;
	// param.b_cabac = 0;
	//param.i_cqm_preset = X264_CQM_FLAT;
	//param.i_bframe = 0;
	//param.analyse.i_weighted_pred = X264_WEIGHTP_NONE;

	// 码率控制
	param.rc.i_rc_method = X264_RC_ABR;
	param.rc.i_bitrate = cfg->kbitrate;
	//param.rc.f_qcompress = 0.0;
	//param.rc.f_rate_tolerance = 0.01;
	param.rc.i_vbv_max_bitrate = (int)(cfg->kbitrate * 1.1);
	param.rc.i_vbv_buffer_size = (int)(cfg->kbitrate / 2.0);	// 希望在 500 ms 之内的调整
	//param.rc.f_vbv_buffer_init = 0.7;
	//param.rc.i_qp_constant = 23;
	//param.rc.f_ip_factor = 1.4;
	//param.rc.f_pb_factor = 1.3;
	//param.rc.i_qp_min = 15;
	//param.rc.f_rf_constant = 27;
	//param.rc.f_rf_constant_max = 51;
	//param.rc.i_qp_step = 10;
	param.rc.i_qp_max = 52;
	param.rc.i_qp_step = 6;
	//param.rc.i_aq_mode = X264_AQ_VARIANCE;
	//param.rc.i_qp_step = 5;	// 
	// param.rc.i_lookahead = 1;

//	x264_param_apply_profile(&param, "main");
//	param.i_level_idc = 30;
	x264_ = x264_encoder_open(&param);
	if (!x264_) {
		ms_error("Fail to create x264 encoder.");
	}
}

X264::~X264(void)
{
	if (x264_)
		x264_encoder_close(x264_);
	rfc3984_destroy(packer_);
}

void X264::force_key_frame()
{
	force_key_ = true;
}

static void x264_nals_to_msgb(x264_nal_t *xnals, int num_nals, MSQueue *nalus){
	int i;
	mblk_t *m;
	/*int bytes;*/
	//fprintf(stderr, "[vmixer]: nals=%d\n", num_nals);
	for (i = 0; i < num_nals; ++i) {
		m=allocb(xnals[i].i_payload + 10, 0);
		unsigned char *p = xnals[i].p_payload;
		unsigned int len = htonl(*(int*)p);		    /* If param->b_annexb is set, Annex-B bytestream with startcode.
													 * Otherwise, startcode is replaced with a 4-byte size.
													 * This size is the size used in mp4/similar muxing; it is equal to i_payload-4 */
		assert(xnals[i].i_payload == len + 4);
		memcpy(m->b_wptr, p+4, len);
		//fprintf(stderr, "  type=%i, len=%d, %02x %02x %02x %02x %02x %02x %02x %02x\n",
		//	xnals[i].i_type, len, p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12]);
		m->b_wptr += len;

		ms_queue_put(nalus, m);
	}
}

int X264::encode(unsigned char *data[4], int stride[4], MSQueue *output, X264FrameState *state)
{
	x264_picture_t xpic;
	x264_picture_t oxpic;
	x264_nal_t *nals = 0;
	int nals_num = 0;

	x264_picture_init(&xpic);
	x264_picture_init(&oxpic);

	// 是否强制输出关键帧
	if (force_key_) {
		force_key_ = false;
		xpic.i_type = X264_TYPE_IDR;
	}
	else
		xpic.i_type = X264_TYPE_AUTO;

	//xpic.i_qpplus1 = 0;	// ?
	//xpic.param = 0;

	xpic.img.i_csp = X264_CSP_I420;	// YUV420P
	xpic.img.i_plane = 3;
	xpic.img.plane[0] = data[0];
	xpic.img.plane[1] = data[1];
	xpic.img.plane[2] = data[2];
	xpic.img.plane[3] = 0;
	xpic.img.i_stride[0] = stride[0];
	xpic.img.i_stride[1] = stride[1];
	xpic.img.i_stride[2] = stride[2];
	xpic.img.i_stride[3] = 0;
	xpic.i_pts = next_pts_;

	if (x264_encoder_encode(x264_, &nals, &nals_num, &xpic, &oxpic) >= 0) {
		x264_nals_to_msgb(nals, nals_num, output);

		state->frame_type = oxpic.i_type;
		state->pts = oxpic.i_pts;
		state->dts = oxpic.i_dts;
		state->qp = oxpic.i_qpplus1;
		state->nals = nals_num;
		state->bytes = 0;
		for (int i = 0; i < nals_num; i++) {
			state->bytes += nals[i].i_payload;
		}

		next_pts_++;
	}

	return nals_num;
}

void X264::rfc3984_pack(MSQueue *nals, MSQueue *output, uint32_t stamp)
{
	::rfc3984_pack(packer_, nals, output, stamp);
}
