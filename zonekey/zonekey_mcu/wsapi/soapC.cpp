/* soapC.cpp
   Generated by gSOAP 2.8.17r from zonekey.mcu.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.17r 2014-05-29 12:43:01 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_zkmcu__getParams:
		return soap_in_zkmcu__getParams(soap, NULL, NULL, "zkmcu:getParams");
	case SOAP_TYPE_zkmcu__getParamsResponse:
		return soap_in_zkmcu__getParamsResponse(soap, NULL, NULL, "zkmcu:getParamsResponse");
	case SOAP_TYPE_zkmcu__setParams:
		return soap_in_zkmcu__setParams(soap, NULL, NULL, "zkmcu:setParams");
	case SOAP_TYPE_zkmcu__KeyValueArrayResponse:
		return soap_in_zkmcu__KeyValueArrayResponse(soap, NULL, NULL, "zkmcu:KeyValueArrayResponse");
	case SOAP_TYPE_zkmcu__KeyValueArray:
		return soap_in_zkmcu__KeyValueArray(soap, NULL, NULL, "zkmcu:KeyValueArray");
	case SOAP_TYPE_zkmcu__KeyValue:
		return soap_in_zkmcu__KeyValue(soap, NULL, NULL, "zkmcu:KeyValue");
	case SOAP_TYPE_zkmcu__delStream:
		return soap_in_zkmcu__delStream(soap, NULL, NULL, "zkmcu:delStream");
	case SOAP_TYPE_zkmcu__addStream:
		return soap_in_zkmcu__addStream(soap, NULL, NULL, "zkmcu:addStream");
	case SOAP_TYPE_zkmcu__AddStreamResponse:
		return soap_in_zkmcu__AddStreamResponse(soap, NULL, NULL, "zkmcu:AddStreamResponse");
	case SOAP_TYPE_zkmcu__AddStreamRequest:
		return soap_in_zkmcu__AddStreamRequest(soap, NULL, NULL, "zkmcu:AddStreamRequest");
	case SOAP_TYPE_zkmcu__delSink:
		return soap_in_zkmcu__delSink(soap, NULL, NULL, "zkmcu:delSink");
	case SOAP_TYPE_zkmcu__addSink:
		return soap_in_zkmcu__addSink(soap, NULL, NULL, "zkmcu:addSink");
	case SOAP_TYPE_zkmcu__AddSinkResponse:
		return soap_in_zkmcu__AddSinkResponse(soap, NULL, NULL, "zkmcu:AddSinkResponse");
	case SOAP_TYPE_zkmcu__AddSinkRequest:
		return soap_in_zkmcu__AddSinkRequest(soap, NULL, NULL, "zkmcu:AddSinkRequest");
	case SOAP_TYPE_zkmcu__delSource:
		return soap_in_zkmcu__delSource(soap, NULL, NULL, "zkmcu:delSource");
	case SOAP_TYPE_zkmcu__addSource:
		return soap_in_zkmcu__addSource(soap, NULL, NULL, "zkmcu:addSource");
	case SOAP_TYPE_zkmcu__AddSourceResponse:
		return soap_in_zkmcu__AddSourceResponse(soap, NULL, NULL, "zkmcu:AddSourceResponse");
	case SOAP_TYPE_zkmcu__AddSourceRequest:
		return soap_in_zkmcu__AddSourceRequest(soap, NULL, NULL, "zkmcu:AddSourceRequest");
	case SOAP_TYPE_zkmcu__MediaEndPoint:
		return soap_in_zkmcu__MediaEndPoint(soap, NULL, NULL, "zkmcu:MediaEndPoint");
	case SOAP_TYPE_zkmcu__infoConference:
		return soap_in_zkmcu__infoConference(soap, NULL, NULL, "zkmcu:infoConference");
	case SOAP_TYPE_zkmcu__ConferenceInfoResponse:
		return soap_in_zkmcu__ConferenceInfoResponse(soap, NULL, NULL, "zkmcu:ConferenceInfoResponse");
	case SOAP_TYPE_zkmcu__ConferenceInfo:
		return soap_in_zkmcu__ConferenceInfo(soap, NULL, NULL, "zkmcu:ConferenceInfo");
	case SOAP_TYPE_zkmcu__SinkInfoArray:
		return soap_in_zkmcu__SinkInfoArray(soap, NULL, NULL, "zkmcu:SinkInfoArray");
	case SOAP_TYPE_zkmcu__SinkInfo:
		return soap_in_zkmcu__SinkInfo(soap, NULL, NULL, "zkmcu:SinkInfo");
	case SOAP_TYPE_zkmcu__SourceInfoArray:
		return soap_in_zkmcu__SourceInfoArray(soap, NULL, NULL, "zkmcu:SourceInfoArray");
	case SOAP_TYPE_zkmcu__SourceInfo:
		return soap_in_zkmcu__SourceInfo(soap, NULL, NULL, "zkmcu:SourceInfo");
	case SOAP_TYPE_zkmcu__StreamInfoArray:
		return soap_in_zkmcu__StreamInfoArray(soap, NULL, NULL, "zkmcu:StreamInfoArray");
	case SOAP_TYPE_zkmcu__StreamInfo:
		return soap_in_zkmcu__StreamInfo(soap, NULL, NULL, "zkmcu:StreamInfo");
	case SOAP_TYPE_zkmcu__listConferences:
		return soap_in_zkmcu__listConferences(soap, NULL, NULL, "zkmcu:listConferences");
	case SOAP_TYPE_zkmcu__listConferencesResponse:
		return soap_in_zkmcu__listConferencesResponse(soap, NULL, NULL, "zkmcu:listConferencesResponse");
	case SOAP_TYPE_zkmcu__ConferenceIdArrayResponse:
		return soap_in_zkmcu__ConferenceIdArrayResponse(soap, NULL, NULL, "zkmcu:ConferenceIdArrayResponse");
	case SOAP_TYPE_zkmcu__ConferenceIdArray:
		return soap_in_zkmcu__ConferenceIdArray(soap, NULL, NULL, "zkmcu:ConferenceIdArray");
	case SOAP_TYPE_zkmcu__destroyConference:
		return soap_in_zkmcu__destroyConference(soap, NULL, NULL, "zkmcu:destroyConference");
	case SOAP_TYPE_zkmcu__createConference:
		return soap_in_zkmcu__createConference(soap, NULL, NULL, "zkmcu:createConference");
	case SOAP_TYPE_zkmcu__CreateConferenceResponse:
		return soap_in_zkmcu__CreateConferenceResponse(soap, NULL, NULL, "zkmcu:CreateConferenceResponse");
	case SOAP_TYPE_zkmcu__CreateConference:
		return soap_in_zkmcu__CreateConference(soap, NULL, NULL, "zkmcu:CreateConference");
	case SOAP_TYPE_zkmcu__getSysInfo:
		return soap_in_zkmcu__getSysInfo(soap, NULL, NULL, "zkmcu:getSysInfo");
	case SOAP_TYPE_zkmcu__SysInfoResponse:
		return soap_in_zkmcu__SysInfoResponse(soap, NULL, NULL, "zkmcu:SysInfoResponse");
	case SOAP_TYPE_zkmcu__SysInfo:
		return soap_in_zkmcu__SysInfo(soap, NULL, NULL, "zkmcu:SysInfo");
	case SOAP_TYPE_zkmcu__getVersion:
		return soap_in_zkmcu__getVersion(soap, NULL, NULL, "zkmcu:getVersion");
	case SOAP_TYPE_zkmcu__getVersionResponse:
		return soap_in_zkmcu__getVersionResponse(soap, NULL, NULL, "zkmcu:getVersionResponse");
	case SOAP_TYPE_PointerTozkmcu__KeyValueArray:
		return soap_in_PointerTozkmcu__KeyValueArray(soap, NULL, NULL, "zkmcu:KeyValueArray");
	case SOAP_TYPE_PointerTozkmcu__KeyValue:
		return soap_in_PointerTozkmcu__KeyValue(soap, NULL, NULL, "zkmcu:KeyValue");
	case SOAP_TYPE_PointerTozkmcu__AddStreamRequest:
		return soap_in_PointerTozkmcu__AddStreamRequest(soap, NULL, NULL, "zkmcu:AddStreamRequest");
	case SOAP_TYPE_PointerTozkmcu__AddSinkRequest:
		return soap_in_PointerTozkmcu__AddSinkRequest(soap, NULL, NULL, "zkmcu:AddSinkRequest");
	case SOAP_TYPE_PointerTozkmcu__AddSourceRequest:
		return soap_in_PointerTozkmcu__AddSourceRequest(soap, NULL, NULL, "zkmcu:AddSourceRequest");
	case SOAP_TYPE_PointerTozkmcu__SinkInfoArray:
		return soap_in_PointerTozkmcu__SinkInfoArray(soap, NULL, NULL, "zkmcu:SinkInfoArray");
	case SOAP_TYPE_PointerTozkmcu__SourceInfoArray:
		return soap_in_PointerTozkmcu__SourceInfoArray(soap, NULL, NULL, "zkmcu:SourceInfoArray");
	case SOAP_TYPE_PointerTozkmcu__StreamInfoArray:
		return soap_in_PointerTozkmcu__StreamInfoArray(soap, NULL, NULL, "zkmcu:StreamInfoArray");
	case SOAP_TYPE_PointerTozkmcu__SinkInfo:
		return soap_in_PointerTozkmcu__SinkInfo(soap, NULL, NULL, "zkmcu:SinkInfo");
	case SOAP_TYPE_PointerTozkmcu__SourceInfo:
		return soap_in_PointerTozkmcu__SourceInfo(soap, NULL, NULL, "zkmcu:SourceInfo");
	case SOAP_TYPE_PointerTozkmcu__StreamInfo:
		return soap_in_PointerTozkmcu__StreamInfo(soap, NULL, NULL, "zkmcu:StreamInfo");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTozkmcu__CreateConference:
		return soap_in_PointerTozkmcu__CreateConference(soap, NULL, NULL, "zkmcu:CreateConference");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:getParams"))
		{	*type = SOAP_TYPE_zkmcu__getParams;
			return soap_in_zkmcu__getParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:getParamsResponse"))
		{	*type = SOAP_TYPE_zkmcu__getParamsResponse;
			return soap_in_zkmcu__getParamsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:setParams"))
		{	*type = SOAP_TYPE_zkmcu__setParams;
			return soap_in_zkmcu__setParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:KeyValueArrayResponse"))
		{	*type = SOAP_TYPE_zkmcu__KeyValueArrayResponse;
			return soap_in_zkmcu__KeyValueArrayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:KeyValueArray"))
		{	*type = SOAP_TYPE_zkmcu__KeyValueArray;
			return soap_in_zkmcu__KeyValueArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:KeyValue"))
		{	*type = SOAP_TYPE_zkmcu__KeyValue;
			return soap_in_zkmcu__KeyValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:delStream"))
		{	*type = SOAP_TYPE_zkmcu__delStream;
			return soap_in_zkmcu__delStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:addStream"))
		{	*type = SOAP_TYPE_zkmcu__addStream;
			return soap_in_zkmcu__addStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:AddStreamResponse"))
		{	*type = SOAP_TYPE_zkmcu__AddStreamResponse;
			return soap_in_zkmcu__AddStreamResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:AddStreamRequest"))
		{	*type = SOAP_TYPE_zkmcu__AddStreamRequest;
			return soap_in_zkmcu__AddStreamRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:delSink"))
		{	*type = SOAP_TYPE_zkmcu__delSink;
			return soap_in_zkmcu__delSink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:addSink"))
		{	*type = SOAP_TYPE_zkmcu__addSink;
			return soap_in_zkmcu__addSink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:AddSinkResponse"))
		{	*type = SOAP_TYPE_zkmcu__AddSinkResponse;
			return soap_in_zkmcu__AddSinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:AddSinkRequest"))
		{	*type = SOAP_TYPE_zkmcu__AddSinkRequest;
			return soap_in_zkmcu__AddSinkRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:delSource"))
		{	*type = SOAP_TYPE_zkmcu__delSource;
			return soap_in_zkmcu__delSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:addSource"))
		{	*type = SOAP_TYPE_zkmcu__addSource;
			return soap_in_zkmcu__addSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:AddSourceResponse"))
		{	*type = SOAP_TYPE_zkmcu__AddSourceResponse;
			return soap_in_zkmcu__AddSourceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:AddSourceRequest"))
		{	*type = SOAP_TYPE_zkmcu__AddSourceRequest;
			return soap_in_zkmcu__AddSourceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:MediaEndPoint"))
		{	*type = SOAP_TYPE_zkmcu__MediaEndPoint;
			return soap_in_zkmcu__MediaEndPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:infoConference"))
		{	*type = SOAP_TYPE_zkmcu__infoConference;
			return soap_in_zkmcu__infoConference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:ConferenceInfoResponse"))
		{	*type = SOAP_TYPE_zkmcu__ConferenceInfoResponse;
			return soap_in_zkmcu__ConferenceInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:ConferenceInfo"))
		{	*type = SOAP_TYPE_zkmcu__ConferenceInfo;
			return soap_in_zkmcu__ConferenceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:SinkInfoArray"))
		{	*type = SOAP_TYPE_zkmcu__SinkInfoArray;
			return soap_in_zkmcu__SinkInfoArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:SinkInfo"))
		{	*type = SOAP_TYPE_zkmcu__SinkInfo;
			return soap_in_zkmcu__SinkInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:SourceInfoArray"))
		{	*type = SOAP_TYPE_zkmcu__SourceInfoArray;
			return soap_in_zkmcu__SourceInfoArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:SourceInfo"))
		{	*type = SOAP_TYPE_zkmcu__SourceInfo;
			return soap_in_zkmcu__SourceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:StreamInfoArray"))
		{	*type = SOAP_TYPE_zkmcu__StreamInfoArray;
			return soap_in_zkmcu__StreamInfoArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:StreamInfo"))
		{	*type = SOAP_TYPE_zkmcu__StreamInfo;
			return soap_in_zkmcu__StreamInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:listConferences"))
		{	*type = SOAP_TYPE_zkmcu__listConferences;
			return soap_in_zkmcu__listConferences(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:listConferencesResponse"))
		{	*type = SOAP_TYPE_zkmcu__listConferencesResponse;
			return soap_in_zkmcu__listConferencesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:ConferenceIdArrayResponse"))
		{	*type = SOAP_TYPE_zkmcu__ConferenceIdArrayResponse;
			return soap_in_zkmcu__ConferenceIdArrayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:ConferenceIdArray"))
		{	*type = SOAP_TYPE_zkmcu__ConferenceIdArray;
			return soap_in_zkmcu__ConferenceIdArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:destroyConference"))
		{	*type = SOAP_TYPE_zkmcu__destroyConference;
			return soap_in_zkmcu__destroyConference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:createConference"))
		{	*type = SOAP_TYPE_zkmcu__createConference;
			return soap_in_zkmcu__createConference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:CreateConferenceResponse"))
		{	*type = SOAP_TYPE_zkmcu__CreateConferenceResponse;
			return soap_in_zkmcu__CreateConferenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:CreateConference"))
		{	*type = SOAP_TYPE_zkmcu__CreateConference;
			return soap_in_zkmcu__CreateConference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:getSysInfo"))
		{	*type = SOAP_TYPE_zkmcu__getSysInfo;
			return soap_in_zkmcu__getSysInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:SysInfoResponse"))
		{	*type = SOAP_TYPE_zkmcu__SysInfoResponse;
			return soap_in_zkmcu__SysInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:SysInfo"))
		{	*type = SOAP_TYPE_zkmcu__SysInfo;
			return soap_in_zkmcu__SysInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:getVersion"))
		{	*type = SOAP_TYPE_zkmcu__getVersion;
			return soap_in_zkmcu__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "zkmcu:getVersionResponse"))
		{	*type = SOAP_TYPE_zkmcu__getVersionResponse;
			return soap_in_zkmcu__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_zkmcu__getParams:
		return soap_out_zkmcu__getParams(soap, tag, id, (const struct zkmcu__getParams *)ptr, "zkmcu:getParams");
	case SOAP_TYPE_zkmcu__getParamsResponse:
		return soap_out_zkmcu__getParamsResponse(soap, tag, id, (const struct zkmcu__getParamsResponse *)ptr, "zkmcu:getParamsResponse");
	case SOAP_TYPE_zkmcu__setParams:
		return soap_out_zkmcu__setParams(soap, tag, id, (const struct zkmcu__setParams *)ptr, "zkmcu:setParams");
	case SOAP_TYPE_zkmcu__KeyValueArrayResponse:
		return soap_out_zkmcu__KeyValueArrayResponse(soap, tag, id, (const struct zkmcu__KeyValueArray *)ptr, "zkmcu:KeyValueArrayResponse");
	case SOAP_TYPE_zkmcu__KeyValueArray:
		return soap_out_zkmcu__KeyValueArray(soap, tag, id, (const struct zkmcu__KeyValueArray *)ptr, "zkmcu:KeyValueArray");
	case SOAP_TYPE_zkmcu__KeyValue:
		return soap_out_zkmcu__KeyValue(soap, tag, id, (const struct zkmcu__KeyValue *)ptr, "zkmcu:KeyValue");
	case SOAP_TYPE_zkmcu__delStream:
		return soap_out_zkmcu__delStream(soap, tag, id, (const struct zkmcu__delStream *)ptr, "zkmcu:delStream");
	case SOAP_TYPE_zkmcu__addStream:
		return soap_out_zkmcu__addStream(soap, tag, id, (const struct zkmcu__addStream *)ptr, "zkmcu:addStream");
	case SOAP_TYPE_zkmcu__AddStreamResponse:
		return soap_out_zkmcu__AddStreamResponse(soap, tag, id, (const struct zkmcu__AddStreamResponse *)ptr, "zkmcu:AddStreamResponse");
	case SOAP_TYPE_zkmcu__AddStreamRequest:
		return soap_out_zkmcu__AddStreamRequest(soap, tag, id, (const struct zkmcu__AddStreamRequest *)ptr, "zkmcu:AddStreamRequest");
	case SOAP_TYPE_zkmcu__delSink:
		return soap_out_zkmcu__delSink(soap, tag, id, (const struct zkmcu__delSink *)ptr, "zkmcu:delSink");
	case SOAP_TYPE_zkmcu__addSink:
		return soap_out_zkmcu__addSink(soap, tag, id, (const struct zkmcu__addSink *)ptr, "zkmcu:addSink");
	case SOAP_TYPE_zkmcu__AddSinkResponse:
		return soap_out_zkmcu__AddSinkResponse(soap, tag, id, (const struct zkmcu__AddSinkResponse *)ptr, "zkmcu:AddSinkResponse");
	case SOAP_TYPE_zkmcu__AddSinkRequest:
		return soap_out_zkmcu__AddSinkRequest(soap, tag, id, (const struct zkmcu__AddSinkRequest *)ptr, "zkmcu:AddSinkRequest");
	case SOAP_TYPE_zkmcu__delSource:
		return soap_out_zkmcu__delSource(soap, tag, id, (const struct zkmcu__delSource *)ptr, "zkmcu:delSource");
	case SOAP_TYPE_zkmcu__addSource:
		return soap_out_zkmcu__addSource(soap, tag, id, (const struct zkmcu__addSource *)ptr, "zkmcu:addSource");
	case SOAP_TYPE_zkmcu__AddSourceResponse:
		return soap_out_zkmcu__AddSourceResponse(soap, tag, id, (const struct zkmcu__AddSourceResponse *)ptr, "zkmcu:AddSourceResponse");
	case SOAP_TYPE_zkmcu__AddSourceRequest:
		return soap_out_zkmcu__AddSourceRequest(soap, tag, id, (const struct zkmcu__AddSourceRequest *)ptr, "zkmcu:AddSourceRequest");
	case SOAP_TYPE_zkmcu__MediaEndPoint:
		return soap_out_zkmcu__MediaEndPoint(soap, tag, id, (const struct zkmcu__MediaEndPoint *)ptr, "zkmcu:MediaEndPoint");
	case SOAP_TYPE_zkmcu__infoConference:
		return soap_out_zkmcu__infoConference(soap, tag, id, (const struct zkmcu__infoConference *)ptr, "zkmcu:infoConference");
	case SOAP_TYPE_zkmcu__ConferenceInfoResponse:
		return soap_out_zkmcu__ConferenceInfoResponse(soap, tag, id, (const struct zkmcu__ConferenceInfo *)ptr, "zkmcu:ConferenceInfoResponse");
	case SOAP_TYPE_zkmcu__ConferenceInfo:
		return soap_out_zkmcu__ConferenceInfo(soap, tag, id, (const struct zkmcu__ConferenceInfo *)ptr, "zkmcu:ConferenceInfo");
	case SOAP_TYPE_zkmcu__SinkInfoArray:
		return soap_out_zkmcu__SinkInfoArray(soap, tag, id, (const struct zkmcu__SinkInfoArray *)ptr, "zkmcu:SinkInfoArray");
	case SOAP_TYPE_zkmcu__SinkInfo:
		return soap_out_zkmcu__SinkInfo(soap, tag, id, (const struct zkmcu__SinkInfo *)ptr, "zkmcu:SinkInfo");
	case SOAP_TYPE_zkmcu__SourceInfoArray:
		return soap_out_zkmcu__SourceInfoArray(soap, tag, id, (const struct zkmcu__SourceInfoArray *)ptr, "zkmcu:SourceInfoArray");
	case SOAP_TYPE_zkmcu__SourceInfo:
		return soap_out_zkmcu__SourceInfo(soap, tag, id, (const struct zkmcu__SourceInfo *)ptr, "zkmcu:SourceInfo");
	case SOAP_TYPE_zkmcu__StreamInfoArray:
		return soap_out_zkmcu__StreamInfoArray(soap, tag, id, (const struct zkmcu__StreamInfoArray *)ptr, "zkmcu:StreamInfoArray");
	case SOAP_TYPE_zkmcu__StreamInfo:
		return soap_out_zkmcu__StreamInfo(soap, tag, id, (const struct zkmcu__StreamInfo *)ptr, "zkmcu:StreamInfo");
	case SOAP_TYPE_zkmcu__listConferences:
		return soap_out_zkmcu__listConferences(soap, tag, id, (const struct zkmcu__listConferences *)ptr, "zkmcu:listConferences");
	case SOAP_TYPE_zkmcu__listConferencesResponse:
		return soap_out_zkmcu__listConferencesResponse(soap, tag, id, (const struct zkmcu__listConferencesResponse *)ptr, "zkmcu:listConferencesResponse");
	case SOAP_TYPE_zkmcu__ConferenceIdArrayResponse:
		return soap_out_zkmcu__ConferenceIdArrayResponse(soap, tag, id, (const struct zkmcu__ConferenceIdArray *)ptr, "zkmcu:ConferenceIdArrayResponse");
	case SOAP_TYPE_zkmcu__ConferenceIdArray:
		return soap_out_zkmcu__ConferenceIdArray(soap, tag, id, (const struct zkmcu__ConferenceIdArray *)ptr, "zkmcu:ConferenceIdArray");
	case SOAP_TYPE_zkmcu__destroyConference:
		return soap_out_zkmcu__destroyConference(soap, tag, id, (const struct zkmcu__destroyConference *)ptr, "zkmcu:destroyConference");
	case SOAP_TYPE_zkmcu__createConference:
		return soap_out_zkmcu__createConference(soap, tag, id, (const struct zkmcu__createConference *)ptr, "zkmcu:createConference");
	case SOAP_TYPE_zkmcu__CreateConferenceResponse:
		return soap_out_zkmcu__CreateConferenceResponse(soap, tag, id, (const struct zkmcu__CreateConferenceResponse *)ptr, "zkmcu:CreateConferenceResponse");
	case SOAP_TYPE_zkmcu__CreateConference:
		return soap_out_zkmcu__CreateConference(soap, tag, id, (const struct zkmcu__CreateConference *)ptr, "zkmcu:CreateConference");
	case SOAP_TYPE_zkmcu__getSysInfo:
		return soap_out_zkmcu__getSysInfo(soap, tag, id, (const struct zkmcu__getSysInfo *)ptr, "zkmcu:getSysInfo");
	case SOAP_TYPE_zkmcu__SysInfoResponse:
		return soap_out_zkmcu__SysInfoResponse(soap, tag, id, (const struct zkmcu__SysInfo *)ptr, "zkmcu:SysInfoResponse");
	case SOAP_TYPE_zkmcu__SysInfo:
		return soap_out_zkmcu__SysInfo(soap, tag, id, (const struct zkmcu__SysInfo *)ptr, "zkmcu:SysInfo");
	case SOAP_TYPE_zkmcu__getVersion:
		return soap_out_zkmcu__getVersion(soap, tag, id, (const struct zkmcu__getVersion *)ptr, "zkmcu:getVersion");
	case SOAP_TYPE_zkmcu__getVersionResponse:
		return soap_out_zkmcu__getVersionResponse(soap, tag, id, (const struct zkmcu__getVersionResponse *)ptr, "zkmcu:getVersionResponse");
	case SOAP_TYPE_PointerTozkmcu__KeyValueArray:
		return soap_out_PointerTozkmcu__KeyValueArray(soap, tag, id, (struct zkmcu__KeyValueArray *const*)ptr, "zkmcu:KeyValueArray");
	case SOAP_TYPE_PointerTozkmcu__KeyValue:
		return soap_out_PointerTozkmcu__KeyValue(soap, tag, id, (struct zkmcu__KeyValue *const*)ptr, "zkmcu:KeyValue");
	case SOAP_TYPE_PointerTozkmcu__AddStreamRequest:
		return soap_out_PointerTozkmcu__AddStreamRequest(soap, tag, id, (struct zkmcu__AddStreamRequest *const*)ptr, "zkmcu:AddStreamRequest");
	case SOAP_TYPE_PointerTozkmcu__AddSinkRequest:
		return soap_out_PointerTozkmcu__AddSinkRequest(soap, tag, id, (struct zkmcu__AddSinkRequest *const*)ptr, "zkmcu:AddSinkRequest");
	case SOAP_TYPE_PointerTozkmcu__AddSourceRequest:
		return soap_out_PointerTozkmcu__AddSourceRequest(soap, tag, id, (struct zkmcu__AddSourceRequest *const*)ptr, "zkmcu:AddSourceRequest");
	case SOAP_TYPE_PointerTozkmcu__SinkInfoArray:
		return soap_out_PointerTozkmcu__SinkInfoArray(soap, tag, id, (struct zkmcu__SinkInfoArray *const*)ptr, "zkmcu:SinkInfoArray");
	case SOAP_TYPE_PointerTozkmcu__SourceInfoArray:
		return soap_out_PointerTozkmcu__SourceInfoArray(soap, tag, id, (struct zkmcu__SourceInfoArray *const*)ptr, "zkmcu:SourceInfoArray");
	case SOAP_TYPE_PointerTozkmcu__StreamInfoArray:
		return soap_out_PointerTozkmcu__StreamInfoArray(soap, tag, id, (struct zkmcu__StreamInfoArray *const*)ptr, "zkmcu:StreamInfoArray");
	case SOAP_TYPE_PointerTozkmcu__SinkInfo:
		return soap_out_PointerTozkmcu__SinkInfo(soap, tag, id, (struct zkmcu__SinkInfo *const*)ptr, "zkmcu:SinkInfo");
	case SOAP_TYPE_PointerTozkmcu__SourceInfo:
		return soap_out_PointerTozkmcu__SourceInfo(soap, tag, id, (struct zkmcu__SourceInfo *const*)ptr, "zkmcu:SourceInfo");
	case SOAP_TYPE_PointerTozkmcu__StreamInfo:
		return soap_out_PointerTozkmcu__StreamInfo(soap, tag, id, (struct zkmcu__StreamInfo *const*)ptr, "zkmcu:StreamInfo");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTozkmcu__CreateConference:
		return soap_out_PointerTozkmcu__CreateConference(soap, tag, id, (struct zkmcu__CreateConference *const*)ptr, "zkmcu:CreateConference");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_zkmcu__getParams:
		soap_serialize_zkmcu__getParams(soap, (const struct zkmcu__getParams *)ptr);
		break;
	case SOAP_TYPE_zkmcu__getParamsResponse:
		soap_serialize_zkmcu__getParamsResponse(soap, (const struct zkmcu__getParamsResponse *)ptr);
		break;
	case SOAP_TYPE_zkmcu__setParams:
		soap_serialize_zkmcu__setParams(soap, (const struct zkmcu__setParams *)ptr);
		break;
	case SOAP_TYPE_zkmcu__KeyValueArrayResponse:
		soap_serialize_zkmcu__KeyValueArrayResponse(soap, (const struct zkmcu__KeyValueArray *)ptr);
		break;
	case SOAP_TYPE_zkmcu__KeyValueArray:
		soap_serialize_zkmcu__KeyValueArray(soap, (const struct zkmcu__KeyValueArray *)ptr);
		break;
	case SOAP_TYPE_zkmcu__KeyValue:
		soap_serialize_zkmcu__KeyValue(soap, (const struct zkmcu__KeyValue *)ptr);
		break;
	case SOAP_TYPE_zkmcu__delStream:
		soap_serialize_zkmcu__delStream(soap, (const struct zkmcu__delStream *)ptr);
		break;
	case SOAP_TYPE_zkmcu__addStream:
		soap_serialize_zkmcu__addStream(soap, (const struct zkmcu__addStream *)ptr);
		break;
	case SOAP_TYPE_zkmcu__AddStreamResponse:
		soap_serialize_zkmcu__AddStreamResponse(soap, (const struct zkmcu__AddStreamResponse *)ptr);
		break;
	case SOAP_TYPE_zkmcu__AddStreamRequest:
		soap_serialize_zkmcu__AddStreamRequest(soap, (const struct zkmcu__AddStreamRequest *)ptr);
		break;
	case SOAP_TYPE_zkmcu__delSink:
		soap_serialize_zkmcu__delSink(soap, (const struct zkmcu__delSink *)ptr);
		break;
	case SOAP_TYPE_zkmcu__addSink:
		soap_serialize_zkmcu__addSink(soap, (const struct zkmcu__addSink *)ptr);
		break;
	case SOAP_TYPE_zkmcu__AddSinkResponse:
		soap_serialize_zkmcu__AddSinkResponse(soap, (const struct zkmcu__AddSinkResponse *)ptr);
		break;
	case SOAP_TYPE_zkmcu__AddSinkRequest:
		soap_serialize_zkmcu__AddSinkRequest(soap, (const struct zkmcu__AddSinkRequest *)ptr);
		break;
	case SOAP_TYPE_zkmcu__delSource:
		soap_serialize_zkmcu__delSource(soap, (const struct zkmcu__delSource *)ptr);
		break;
	case SOAP_TYPE_zkmcu__addSource:
		soap_serialize_zkmcu__addSource(soap, (const struct zkmcu__addSource *)ptr);
		break;
	case SOAP_TYPE_zkmcu__AddSourceResponse:
		soap_serialize_zkmcu__AddSourceResponse(soap, (const struct zkmcu__AddSourceResponse *)ptr);
		break;
	case SOAP_TYPE_zkmcu__AddSourceRequest:
		soap_serialize_zkmcu__AddSourceRequest(soap, (const struct zkmcu__AddSourceRequest *)ptr);
		break;
	case SOAP_TYPE_zkmcu__MediaEndPoint:
		soap_serialize_zkmcu__MediaEndPoint(soap, (const struct zkmcu__MediaEndPoint *)ptr);
		break;
	case SOAP_TYPE_zkmcu__infoConference:
		soap_serialize_zkmcu__infoConference(soap, (const struct zkmcu__infoConference *)ptr);
		break;
	case SOAP_TYPE_zkmcu__ConferenceInfoResponse:
		soap_serialize_zkmcu__ConferenceInfoResponse(soap, (const struct zkmcu__ConferenceInfo *)ptr);
		break;
	case SOAP_TYPE_zkmcu__ConferenceInfo:
		soap_serialize_zkmcu__ConferenceInfo(soap, (const struct zkmcu__ConferenceInfo *)ptr);
		break;
	case SOAP_TYPE_zkmcu__SinkInfoArray:
		soap_serialize_zkmcu__SinkInfoArray(soap, (const struct zkmcu__SinkInfoArray *)ptr);
		break;
	case SOAP_TYPE_zkmcu__SinkInfo:
		soap_serialize_zkmcu__SinkInfo(soap, (const struct zkmcu__SinkInfo *)ptr);
		break;
	case SOAP_TYPE_zkmcu__SourceInfoArray:
		soap_serialize_zkmcu__SourceInfoArray(soap, (const struct zkmcu__SourceInfoArray *)ptr);
		break;
	case SOAP_TYPE_zkmcu__SourceInfo:
		soap_serialize_zkmcu__SourceInfo(soap, (const struct zkmcu__SourceInfo *)ptr);
		break;
	case SOAP_TYPE_zkmcu__StreamInfoArray:
		soap_serialize_zkmcu__StreamInfoArray(soap, (const struct zkmcu__StreamInfoArray *)ptr);
		break;
	case SOAP_TYPE_zkmcu__StreamInfo:
		soap_serialize_zkmcu__StreamInfo(soap, (const struct zkmcu__StreamInfo *)ptr);
		break;
	case SOAP_TYPE_zkmcu__listConferences:
		soap_serialize_zkmcu__listConferences(soap, (const struct zkmcu__listConferences *)ptr);
		break;
	case SOAP_TYPE_zkmcu__listConferencesResponse:
		soap_serialize_zkmcu__listConferencesResponse(soap, (const struct zkmcu__listConferencesResponse *)ptr);
		break;
	case SOAP_TYPE_zkmcu__ConferenceIdArrayResponse:
		soap_serialize_zkmcu__ConferenceIdArrayResponse(soap, (const struct zkmcu__ConferenceIdArray *)ptr);
		break;
	case SOAP_TYPE_zkmcu__ConferenceIdArray:
		soap_serialize_zkmcu__ConferenceIdArray(soap, (const struct zkmcu__ConferenceIdArray *)ptr);
		break;
	case SOAP_TYPE_zkmcu__destroyConference:
		soap_serialize_zkmcu__destroyConference(soap, (const struct zkmcu__destroyConference *)ptr);
		break;
	case SOAP_TYPE_zkmcu__createConference:
		soap_serialize_zkmcu__createConference(soap, (const struct zkmcu__createConference *)ptr);
		break;
	case SOAP_TYPE_zkmcu__CreateConferenceResponse:
		soap_serialize_zkmcu__CreateConferenceResponse(soap, (const struct zkmcu__CreateConferenceResponse *)ptr);
		break;
	case SOAP_TYPE_zkmcu__CreateConference:
		soap_serialize_zkmcu__CreateConference(soap, (const struct zkmcu__CreateConference *)ptr);
		break;
	case SOAP_TYPE_zkmcu__getSysInfo:
		soap_serialize_zkmcu__getSysInfo(soap, (const struct zkmcu__getSysInfo *)ptr);
		break;
	case SOAP_TYPE_zkmcu__SysInfoResponse:
		soap_serialize_zkmcu__SysInfoResponse(soap, (const struct zkmcu__SysInfo *)ptr);
		break;
	case SOAP_TYPE_zkmcu__SysInfo:
		soap_serialize_zkmcu__SysInfo(soap, (const struct zkmcu__SysInfo *)ptr);
		break;
	case SOAP_TYPE_zkmcu__getVersion:
		soap_serialize_zkmcu__getVersion(soap, (const struct zkmcu__getVersion *)ptr);
		break;
	case SOAP_TYPE_zkmcu__getVersionResponse:
		soap_serialize_zkmcu__getVersionResponse(soap, (const struct zkmcu__getVersionResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__KeyValueArray:
		soap_serialize_PointerTozkmcu__KeyValueArray(soap, (struct zkmcu__KeyValueArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__KeyValue:
		soap_serialize_PointerTozkmcu__KeyValue(soap, (struct zkmcu__KeyValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__AddStreamRequest:
		soap_serialize_PointerTozkmcu__AddStreamRequest(soap, (struct zkmcu__AddStreamRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__AddSinkRequest:
		soap_serialize_PointerTozkmcu__AddSinkRequest(soap, (struct zkmcu__AddSinkRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__AddSourceRequest:
		soap_serialize_PointerTozkmcu__AddSourceRequest(soap, (struct zkmcu__AddSourceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__SinkInfoArray:
		soap_serialize_PointerTozkmcu__SinkInfoArray(soap, (struct zkmcu__SinkInfoArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__SourceInfoArray:
		soap_serialize_PointerTozkmcu__SourceInfoArray(soap, (struct zkmcu__SourceInfoArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__StreamInfoArray:
		soap_serialize_PointerTozkmcu__StreamInfoArray(soap, (struct zkmcu__StreamInfoArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__SinkInfo:
		soap_serialize_PointerTozkmcu__SinkInfo(soap, (struct zkmcu__SinkInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__SourceInfo:
		soap_serialize_PointerTozkmcu__SourceInfo(soap, (struct zkmcu__SourceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__StreamInfo:
		soap_serialize_PointerTozkmcu__StreamInfo(soap, (struct zkmcu__StreamInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTozkmcu__CreateConference:
		soap_serialize_PointerTozkmcu__CreateConference(soap, (struct zkmcu__CreateConference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_zkmcu__getVersionResponse:
		return (void*)soap_instantiate_zkmcu__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__getVersion:
		return (void*)soap_instantiate_zkmcu__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__SysInfo:
		return (void*)soap_instantiate_zkmcu__SysInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__getSysInfo:
		return (void*)soap_instantiate_zkmcu__getSysInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__CreateConference:
		return (void*)soap_instantiate_zkmcu__CreateConference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__CreateConferenceResponse:
		return (void*)soap_instantiate_zkmcu__CreateConferenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__createConference:
		return (void*)soap_instantiate_zkmcu__createConference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__destroyConference:
		return (void*)soap_instantiate_zkmcu__destroyConference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__ConferenceIdArray:
		return (void*)soap_instantiate_zkmcu__ConferenceIdArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__listConferencesResponse:
		return (void*)soap_instantiate_zkmcu__listConferencesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__listConferences:
		return (void*)soap_instantiate_zkmcu__listConferences(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__StreamInfo:
		return (void*)soap_instantiate_zkmcu__StreamInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__StreamInfoArray:
		return (void*)soap_instantiate_zkmcu__StreamInfoArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__SourceInfo:
		return (void*)soap_instantiate_zkmcu__SourceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__SourceInfoArray:
		return (void*)soap_instantiate_zkmcu__SourceInfoArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__SinkInfo:
		return (void*)soap_instantiate_zkmcu__SinkInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__SinkInfoArray:
		return (void*)soap_instantiate_zkmcu__SinkInfoArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__ConferenceInfo:
		return (void*)soap_instantiate_zkmcu__ConferenceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__infoConference:
		return (void*)soap_instantiate_zkmcu__infoConference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__MediaEndPoint:
		return (void*)soap_instantiate_zkmcu__MediaEndPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__AddSourceRequest:
		return (void*)soap_instantiate_zkmcu__AddSourceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__AddSourceResponse:
		return (void*)soap_instantiate_zkmcu__AddSourceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__addSource:
		return (void*)soap_instantiate_zkmcu__addSource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__delSource:
		return (void*)soap_instantiate_zkmcu__delSource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__AddSinkRequest:
		return (void*)soap_instantiate_zkmcu__AddSinkRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__AddSinkResponse:
		return (void*)soap_instantiate_zkmcu__AddSinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__addSink:
		return (void*)soap_instantiate_zkmcu__addSink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__delSink:
		return (void*)soap_instantiate_zkmcu__delSink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__AddStreamRequest:
		return (void*)soap_instantiate_zkmcu__AddStreamRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__AddStreamResponse:
		return (void*)soap_instantiate_zkmcu__AddStreamResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__addStream:
		return (void*)soap_instantiate_zkmcu__addStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__delStream:
		return (void*)soap_instantiate_zkmcu__delStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__KeyValue:
		return (void*)soap_instantiate_zkmcu__KeyValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__KeyValueArray:
		return (void*)soap_instantiate_zkmcu__KeyValueArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__setParams:
		return (void*)soap_instantiate_zkmcu__setParams(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__getParamsResponse:
		return (void*)soap_instantiate_zkmcu__getParamsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__getParams:
		return (void*)soap_instantiate_zkmcu__getParams(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_zkmcu__SysInfoResponse:
		return (void*)soap_instantiate_zkmcu__SysInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__ConferenceIdArrayResponse:
		return (void*)soap_instantiate_zkmcu__ConferenceIdArrayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__ConferenceInfoResponse:
		return (void*)soap_instantiate_zkmcu__ConferenceInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_zkmcu__KeyValueArrayResponse:
		return (void*)soap_instantiate_zkmcu__KeyValueArrayResponse(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_zkmcu__getVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__getVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__getVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__getVersion:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__getVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__getVersion*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__SysInfo:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__SysInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__SysInfo*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__getSysInfo:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__getSysInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__getSysInfo*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__CreateConference:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__CreateConference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__CreateConference*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__CreateConferenceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__CreateConferenceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__CreateConferenceResponse*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__createConference:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__createConference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__createConference*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__destroyConference:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__destroyConference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__destroyConference*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__ConferenceIdArray:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__ConferenceIdArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__ConferenceIdArray*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__listConferencesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__listConferencesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__listConferencesResponse*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__listConferences:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__listConferences*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__listConferences*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__StreamInfo:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__StreamInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__StreamInfo*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__StreamInfoArray:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__StreamInfoArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__StreamInfoArray*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__SourceInfo:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__SourceInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__SourceInfo*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__SourceInfoArray:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__SourceInfoArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__SourceInfoArray*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__SinkInfo:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__SinkInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__SinkInfo*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__SinkInfoArray:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__SinkInfoArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__SinkInfoArray*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__ConferenceInfo:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__ConferenceInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__ConferenceInfo*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__infoConference:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__infoConference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__infoConference*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__MediaEndPoint:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__MediaEndPoint*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__MediaEndPoint*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__AddSourceRequest:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__AddSourceRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__AddSourceRequest*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__AddSourceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__AddSourceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__AddSourceResponse*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__addSource:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__addSource*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__addSource*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__delSource:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__delSource*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__delSource*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__AddSinkRequest:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__AddSinkRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__AddSinkRequest*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__AddSinkResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__AddSinkResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__AddSinkResponse*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__addSink:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__addSink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__addSink*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__delSink:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__delSink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__delSink*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__AddStreamRequest:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__AddStreamRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__AddStreamRequest*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__AddStreamResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__AddStreamResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__AddStreamResponse*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__addStream:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__addStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__addStream*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__delStream:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__delStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__delStream*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__KeyValue:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__KeyValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__KeyValue*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__KeyValueArray:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__KeyValueArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__KeyValueArray*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__setParams:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__setParams*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__setParams*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__getParamsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__getParamsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__getParamsResponse*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__getParams:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__getParams*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__getParams*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_zkmcu__SysInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__SysInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__SysInfo*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__ConferenceIdArrayResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__ConferenceIdArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__ConferenceIdArray*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__ConferenceInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__ConferenceInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__ConferenceInfo*)p->ptr);
		break;
	case SOAP_TYPE_zkmcu__KeyValueArrayResponse:
		if (p->size < 0)
			SOAP_DELETE((struct zkmcu__KeyValueArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct zkmcu__KeyValueArray*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{	long *p;
	p = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__getParams(struct soap *soap, struct zkmcu__getParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__getParams(struct soap *soap, const struct zkmcu__getParams *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__getParams(struct soap *soap, const char *tag, int id, const struct zkmcu__getParams *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__getParams), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__getParams * SOAP_FMAC4 soap_in_zkmcu__getParams(struct soap *soap, const char *tag, struct zkmcu__getParams *a, const char *type)
{
	size_t soap_flag_cid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__getParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__getParams, sizeof(struct zkmcu__getParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__getParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__getParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__getParams, 0, sizeof(struct zkmcu__getParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__getParams(struct soap *soap, const struct zkmcu__getParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__getParams);
	if (soap_out_zkmcu__getParams(soap, tag?tag:"zkmcu:getParams", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__getParams * SOAP_FMAC4 soap_get_zkmcu__getParams(struct soap *soap, struct zkmcu__getParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__getParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__getParams * SOAP_FMAC2 soap_instantiate_zkmcu__getParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__getParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__getParams, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__getParams);
		if (size)
			*size = sizeof(struct zkmcu__getParams);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__getParams, n);
		if (size)
			*size = n * sizeof(struct zkmcu__getParams);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__getParams*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__getParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__getParams %p -> %p\n", q, p));
	*(struct zkmcu__getParams*)p = *(struct zkmcu__getParams*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__getParamsResponse(struct soap *soap, struct zkmcu__getParamsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_zkmcu__KeyValueArrayResponse(soap, &a->res);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__getParamsResponse(struct soap *soap, const struct zkmcu__getParamsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_zkmcu__KeyValueArrayResponse(soap, &a->res);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__getParamsResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__getParamsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__getParamsResponse), type))
		return soap->error;
	if (soap_out_zkmcu__KeyValueArrayResponse(soap, "res", -1, &a->res, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__getParamsResponse * SOAP_FMAC4 soap_in_zkmcu__getParamsResponse(struct soap *soap, const char *tag, struct zkmcu__getParamsResponse *a, const char *type)
{
	size_t soap_flag_res = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__getParamsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__getParamsResponse, sizeof(struct zkmcu__getParamsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__getParamsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_res && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_zkmcu__KeyValueArrayResponse(soap, "res", &a->res, "zkmcu:KeyValueArrayResponse"))
				{	soap_flag_res--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__getParamsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__getParamsResponse, 0, sizeof(struct zkmcu__getParamsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_res > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__getParamsResponse(struct soap *soap, const struct zkmcu__getParamsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__getParamsResponse);
	if (soap_out_zkmcu__getParamsResponse(soap, tag?tag:"zkmcu:getParamsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__getParamsResponse * SOAP_FMAC4 soap_get_zkmcu__getParamsResponse(struct soap *soap, struct zkmcu__getParamsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__getParamsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__getParamsResponse * SOAP_FMAC2 soap_instantiate_zkmcu__getParamsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__getParamsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__getParamsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__getParamsResponse);
		if (size)
			*size = sizeof(struct zkmcu__getParamsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__getParamsResponse, n);
		if (size)
			*size = n * sizeof(struct zkmcu__getParamsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__getParamsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__getParamsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__getParamsResponse %p -> %p\n", q, p));
	*(struct zkmcu__getParamsResponse*)p = *(struct zkmcu__getParamsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__setParams(struct soap *soap, struct zkmcu__setParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	a->req = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__setParams(struct soap *soap, const struct zkmcu__setParams *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_serialize_PointerTozkmcu__KeyValueArray(soap, &a->req);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__setParams(struct soap *soap, const char *tag, int id, const struct zkmcu__setParams *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__setParams), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__KeyValueArray(soap, "req", -1, &a->req, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__setParams * SOAP_FMAC4 soap_in_zkmcu__setParams(struct soap *soap, const char *tag, struct zkmcu__setParams *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_req = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__setParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__setParams, sizeof(struct zkmcu__setParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__setParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_req && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__KeyValueArray(soap, "req", &a->req, "zkmcu:KeyValueArray"))
				{	soap_flag_req--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__setParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__setParams, 0, sizeof(struct zkmcu__setParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__setParams(struct soap *soap, const struct zkmcu__setParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__setParams);
	if (soap_out_zkmcu__setParams(soap, tag?tag:"zkmcu:setParams", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__setParams * SOAP_FMAC4 soap_get_zkmcu__setParams(struct soap *soap, struct zkmcu__setParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__setParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__setParams * SOAP_FMAC2 soap_instantiate_zkmcu__setParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__setParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__setParams, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__setParams);
		if (size)
			*size = sizeof(struct zkmcu__setParams);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__setParams, n);
		if (size)
			*size = n * sizeof(struct zkmcu__setParams);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__setParams*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__setParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__setParams %p -> %p\n", q, p));
	*(struct zkmcu__setParams*)p = *(struct zkmcu__setParams*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__KeyValueArrayResponse(struct soap *soap, struct zkmcu__KeyValueArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_zkmcu__KeyValueArrayResponse))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_zkmcu__KeyValue);
			soap_serialize_zkmcu__KeyValue(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__KeyValueArrayResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__KeyValueArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_zkmcu__KeyValueArrayResponse);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_zkmcu__KeyValue(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__KeyValueArray * SOAP_FMAC4 soap_in_zkmcu__KeyValueArrayResponse(struct soap *soap, const char *tag, struct zkmcu__KeyValueArray *a, const char *type)
{	int i, j;
	struct zkmcu__KeyValue *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "zkmcu:KeyValue") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct zkmcu__KeyValueArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__KeyValueArrayResponse, sizeof(struct zkmcu__KeyValueArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__KeyValueArrayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_zkmcu__KeyValue(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_zkmcu__KeyValue(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_zkmcu__KeyValue(soap, NULL, a->__ptr + i, "zkmcu:KeyValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct zkmcu__KeyValue *)soap_push_block(soap, NULL, sizeof(struct zkmcu__KeyValue));
				if (!p)
					return NULL;
				SOAP_PLACEMENT_NEW(p, struct zkmcu__KeyValue);
				soap_default_zkmcu__KeyValue(soap, p);
				if (!soap_in_zkmcu__KeyValue(soap, NULL, p, "zkmcu:KeyValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_zkmcu__KeyValue(soap, soap->blist->size/sizeof(struct zkmcu__KeyValue));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__KeyValueArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__KeyValueArrayResponse, 0, sizeof(struct zkmcu__KeyValueArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__KeyValueArrayResponse(struct soap *soap, const struct zkmcu__KeyValueArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_zkmcu__KeyValueArrayResponse);
	if (soap_out_zkmcu__KeyValueArrayResponse(soap, tag?tag:"zkmcu:KeyValueArrayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__KeyValueArray * SOAP_FMAC4 soap_get_zkmcu__KeyValueArrayResponse(struct soap *soap, struct zkmcu__KeyValueArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__KeyValueArrayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__KeyValueArray(struct soap *soap, struct zkmcu__KeyValueArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__KeyValueArray(struct soap *soap, struct zkmcu__KeyValueArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_zkmcu__KeyValueArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_zkmcu__KeyValue);
			soap_serialize_zkmcu__KeyValue(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__KeyValueArray(struct soap *soap, const char *tag, int id, const struct zkmcu__KeyValueArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_zkmcu__KeyValueArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_zkmcu__KeyValue(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__KeyValueArray * SOAP_FMAC4 soap_in_zkmcu__KeyValueArray(struct soap *soap, const char *tag, struct zkmcu__KeyValueArray *a, const char *type)
{	int i, j;
	struct zkmcu__KeyValue *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "zkmcu:KeyValue") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct zkmcu__KeyValueArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__KeyValueArray, sizeof(struct zkmcu__KeyValueArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__KeyValueArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_zkmcu__KeyValue(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_zkmcu__KeyValue(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_zkmcu__KeyValue(soap, NULL, a->__ptr + i, "zkmcu:KeyValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct zkmcu__KeyValue *)soap_push_block(soap, NULL, sizeof(struct zkmcu__KeyValue));
				if (!p)
					return NULL;
				SOAP_PLACEMENT_NEW(p, struct zkmcu__KeyValue);
				soap_default_zkmcu__KeyValue(soap, p);
				if (!soap_in_zkmcu__KeyValue(soap, NULL, p, "zkmcu:KeyValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_zkmcu__KeyValue(soap, soap->blist->size/sizeof(struct zkmcu__KeyValue));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__KeyValueArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__KeyValueArray, 0, sizeof(struct zkmcu__KeyValueArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__KeyValueArray(struct soap *soap, const struct zkmcu__KeyValueArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_zkmcu__KeyValueArray);
	if (soap_out_zkmcu__KeyValueArray(soap, tag?tag:"zkmcu:KeyValueArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__KeyValueArray * SOAP_FMAC4 soap_get_zkmcu__KeyValueArray(struct soap *soap, struct zkmcu__KeyValueArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__KeyValueArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__KeyValueArray * SOAP_FMAC2 soap_instantiate_zkmcu__KeyValueArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__KeyValueArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__KeyValueArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__KeyValueArray);
		if (size)
			*size = sizeof(struct zkmcu__KeyValueArray);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__KeyValueArray, n);
		if (size)
			*size = n * sizeof(struct zkmcu__KeyValueArray);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__KeyValueArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__KeyValueArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__KeyValueArray %p -> %p\n", q, p));
	*(struct zkmcu__KeyValueArray*)p = *(struct zkmcu__KeyValueArray*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__KeyValue(struct soap *soap, struct zkmcu__KeyValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__KeyValue(struct soap *soap, const struct zkmcu__KeyValue *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
	soap_serialize_string(soap, &a->value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__KeyValue(struct soap *soap, const char *tag, int id, const struct zkmcu__KeyValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__KeyValue), type))
		return soap->error;
	if (soap_out_string(soap, "key", -1, &a->key, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__KeyValue * SOAP_FMAC4 soap_in_zkmcu__KeyValue(struct soap *soap, const char *tag, struct zkmcu__KeyValue *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__KeyValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__KeyValue, sizeof(struct zkmcu__KeyValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__KeyValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__KeyValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__KeyValue, 0, sizeof(struct zkmcu__KeyValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__KeyValue(struct soap *soap, const struct zkmcu__KeyValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__KeyValue);
	if (soap_out_zkmcu__KeyValue(soap, tag?tag:"zkmcu:KeyValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__KeyValue * SOAP_FMAC4 soap_get_zkmcu__KeyValue(struct soap *soap, struct zkmcu__KeyValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__KeyValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__KeyValue * SOAP_FMAC2 soap_instantiate_zkmcu__KeyValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__KeyValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__KeyValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__KeyValue);
		if (size)
			*size = sizeof(struct zkmcu__KeyValue);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__KeyValue, n);
		if (size)
			*size = n * sizeof(struct zkmcu__KeyValue);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__KeyValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__KeyValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__KeyValue %p -> %p\n", q, p));
	*(struct zkmcu__KeyValue*)p = *(struct zkmcu__KeyValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__delStream(struct soap *soap, struct zkmcu__delStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	soap_default_int(soap, &a->sourceid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__delStream(struct soap *soap, const struct zkmcu__delStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_embedded(soap, &a->sourceid, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__delStream(struct soap *soap, const char *tag, int id, const struct zkmcu__delStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__delStream), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_int(soap, "sourceid", -1, &a->sourceid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__delStream * SOAP_FMAC4 soap_in_zkmcu__delStream(struct soap *soap, const char *tag, struct zkmcu__delStream *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_sourceid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__delStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__delStream, sizeof(struct zkmcu__delStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__delStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_sourceid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sourceid", &a->sourceid, "xsd:int"))
				{	soap_flag_sourceid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__delStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__delStream, 0, sizeof(struct zkmcu__delStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0 || soap_flag_sourceid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__delStream(struct soap *soap, const struct zkmcu__delStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__delStream);
	if (soap_out_zkmcu__delStream(soap, tag?tag:"zkmcu:delStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__delStream * SOAP_FMAC4 soap_get_zkmcu__delStream(struct soap *soap, struct zkmcu__delStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__delStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__delStream * SOAP_FMAC2 soap_instantiate_zkmcu__delStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__delStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__delStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__delStream);
		if (size)
			*size = sizeof(struct zkmcu__delStream);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__delStream, n);
		if (size)
			*size = n * sizeof(struct zkmcu__delStream);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__delStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__delStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__delStream %p -> %p\n", q, p));
	*(struct zkmcu__delStream*)p = *(struct zkmcu__delStream*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__addStream(struct soap *soap, struct zkmcu__addStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	a->req = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__addStream(struct soap *soap, const struct zkmcu__addStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_serialize_PointerTozkmcu__AddStreamRequest(soap, &a->req);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__addStream(struct soap *soap, const char *tag, int id, const struct zkmcu__addStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__addStream), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__AddStreamRequest(soap, "req", -1, &a->req, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__addStream * SOAP_FMAC4 soap_in_zkmcu__addStream(struct soap *soap, const char *tag, struct zkmcu__addStream *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_req = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__addStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__addStream, sizeof(struct zkmcu__addStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__addStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_req && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__AddStreamRequest(soap, "req", &a->req, "zkmcu:AddStreamRequest"))
				{	soap_flag_req--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__addStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__addStream, 0, sizeof(struct zkmcu__addStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__addStream(struct soap *soap, const struct zkmcu__addStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__addStream);
	if (soap_out_zkmcu__addStream(soap, tag?tag:"zkmcu:addStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__addStream * SOAP_FMAC4 soap_get_zkmcu__addStream(struct soap *soap, struct zkmcu__addStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__addStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__addStream * SOAP_FMAC2 soap_instantiate_zkmcu__addStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__addStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__addStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__addStream);
		if (size)
			*size = sizeof(struct zkmcu__addStream);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__addStream, n);
		if (size)
			*size = n * sizeof(struct zkmcu__addStream);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__addStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__addStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__addStream %p -> %p\n", q, p));
	*(struct zkmcu__addStream*)p = *(struct zkmcu__addStream*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__AddStreamResponse(struct soap *soap, struct zkmcu__AddStreamResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->streamid);
	soap_default_string(soap, &a->reason);
	soap_default_zkmcu__MediaEndPoint(soap, &a->media);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__AddStreamResponse(struct soap *soap, const struct zkmcu__AddStreamResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->streamid, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->reason);
	soap_serialize_zkmcu__MediaEndPoint(soap, &a->media);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__AddStreamResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__AddStreamResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__AddStreamResponse), type))
		return soap->error;
	if (soap_out_int(soap, "streamid", -1, &a->streamid, ""))
		return soap->error;
	if (soap_out_string(soap, "reason", -1, &a->reason, ""))
		return soap->error;
	if (soap_out_zkmcu__MediaEndPoint(soap, "media", -1, &a->media, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__AddStreamResponse * SOAP_FMAC4 soap_in_zkmcu__AddStreamResponse(struct soap *soap, const char *tag, struct zkmcu__AddStreamResponse *a, const char *type)
{
	size_t soap_flag_streamid = 1;
	size_t soap_flag_reason = 0;
	size_t soap_flag_media = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__AddStreamResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__AddStreamResponse, sizeof(struct zkmcu__AddStreamResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__AddStreamResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_streamid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "streamid", &a->streamid, "xsd:int"))
				{	soap_flag_streamid--;
					continue;
				}
			if (soap_flag_reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reason", &a->reason, "xsd:string"))
				{	soap_flag_reason--;
					continue;
				}
			if (soap_flag_media && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_zkmcu__MediaEndPoint(soap, "media", &a->media, "zkmcu:MediaEndPoint"))
				{	soap_flag_media--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddStreamResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__AddStreamResponse, 0, sizeof(struct zkmcu__AddStreamResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_streamid > 0 || soap_flag_media > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__AddStreamResponse(struct soap *soap, const struct zkmcu__AddStreamResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__AddStreamResponse);
	if (soap_out_zkmcu__AddStreamResponse(soap, tag?tag:"zkmcu:AddStreamResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddStreamResponse * SOAP_FMAC4 soap_get_zkmcu__AddStreamResponse(struct soap *soap, struct zkmcu__AddStreamResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__AddStreamResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__AddStreamResponse * SOAP_FMAC2 soap_instantiate_zkmcu__AddStreamResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__AddStreamResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__AddStreamResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__AddStreamResponse);
		if (size)
			*size = sizeof(struct zkmcu__AddStreamResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__AddStreamResponse, n);
		if (size)
			*size = n * sizeof(struct zkmcu__AddStreamResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__AddStreamResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__AddStreamResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__AddStreamResponse %p -> %p\n", q, p));
	*(struct zkmcu__AddStreamResponse*)p = *(struct zkmcu__AddStreamResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__AddStreamRequest(struct soap *soap, struct zkmcu__AddStreamRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->payload);
	soap_default_string(soap, &a->desc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__AddStreamRequest(struct soap *soap, const struct zkmcu__AddStreamRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->payload, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__AddStreamRequest(struct soap *soap, const char *tag, int id, const struct zkmcu__AddStreamRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__AddStreamRequest), type))
		return soap->error;
	if (soap_out_int(soap, "payload", -1, &a->payload, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__AddStreamRequest * SOAP_FMAC4 soap_in_zkmcu__AddStreamRequest(struct soap *soap, const char *tag, struct zkmcu__AddStreamRequest *a, const char *type)
{
	size_t soap_flag_payload = 1;
	size_t soap_flag_desc = 0;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__AddStreamRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__AddStreamRequest, sizeof(struct zkmcu__AddStreamRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__AddStreamRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_payload && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "payload", &a->payload, "xsd:int"))
				{	soap_flag_payload--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddStreamRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__AddStreamRequest, 0, sizeof(struct zkmcu__AddStreamRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_payload > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__AddStreamRequest(struct soap *soap, const struct zkmcu__AddStreamRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__AddStreamRequest);
	if (soap_out_zkmcu__AddStreamRequest(soap, tag?tag:"zkmcu:AddStreamRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddStreamRequest * SOAP_FMAC4 soap_get_zkmcu__AddStreamRequest(struct soap *soap, struct zkmcu__AddStreamRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__AddStreamRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__AddStreamRequest * SOAP_FMAC2 soap_instantiate_zkmcu__AddStreamRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__AddStreamRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__AddStreamRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__AddStreamRequest);
		if (size)
			*size = sizeof(struct zkmcu__AddStreamRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__AddStreamRequest, n);
		if (size)
			*size = n * sizeof(struct zkmcu__AddStreamRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__AddStreamRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__AddStreamRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__AddStreamRequest %p -> %p\n", q, p));
	*(struct zkmcu__AddStreamRequest*)p = *(struct zkmcu__AddStreamRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__delSink(struct soap *soap, struct zkmcu__delSink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	soap_default_int(soap, &a->sinkid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__delSink(struct soap *soap, const struct zkmcu__delSink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_embedded(soap, &a->sinkid, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__delSink(struct soap *soap, const char *tag, int id, const struct zkmcu__delSink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__delSink), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_int(soap, "sinkid", -1, &a->sinkid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__delSink * SOAP_FMAC4 soap_in_zkmcu__delSink(struct soap *soap, const char *tag, struct zkmcu__delSink *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_sinkid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__delSink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__delSink, sizeof(struct zkmcu__delSink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__delSink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_sinkid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sinkid", &a->sinkid, "xsd:int"))
				{	soap_flag_sinkid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__delSink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__delSink, 0, sizeof(struct zkmcu__delSink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0 || soap_flag_sinkid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__delSink(struct soap *soap, const struct zkmcu__delSink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__delSink);
	if (soap_out_zkmcu__delSink(soap, tag?tag:"zkmcu:delSink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__delSink * SOAP_FMAC4 soap_get_zkmcu__delSink(struct soap *soap, struct zkmcu__delSink *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__delSink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__delSink * SOAP_FMAC2 soap_instantiate_zkmcu__delSink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__delSink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__delSink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__delSink);
		if (size)
			*size = sizeof(struct zkmcu__delSink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__delSink, n);
		if (size)
			*size = n * sizeof(struct zkmcu__delSink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__delSink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__delSink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__delSink %p -> %p\n", q, p));
	*(struct zkmcu__delSink*)p = *(struct zkmcu__delSink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__addSink(struct soap *soap, struct zkmcu__addSink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	a->req = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__addSink(struct soap *soap, const struct zkmcu__addSink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_serialize_PointerTozkmcu__AddSinkRequest(soap, &a->req);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__addSink(struct soap *soap, const char *tag, int id, const struct zkmcu__addSink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__addSink), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__AddSinkRequest(soap, "req", -1, &a->req, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__addSink * SOAP_FMAC4 soap_in_zkmcu__addSink(struct soap *soap, const char *tag, struct zkmcu__addSink *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_req = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__addSink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__addSink, sizeof(struct zkmcu__addSink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__addSink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_req && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__AddSinkRequest(soap, "req", &a->req, "zkmcu:AddSinkRequest"))
				{	soap_flag_req--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__addSink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__addSink, 0, sizeof(struct zkmcu__addSink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__addSink(struct soap *soap, const struct zkmcu__addSink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__addSink);
	if (soap_out_zkmcu__addSink(soap, tag?tag:"zkmcu:addSink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__addSink * SOAP_FMAC4 soap_get_zkmcu__addSink(struct soap *soap, struct zkmcu__addSink *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__addSink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__addSink * SOAP_FMAC2 soap_instantiate_zkmcu__addSink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__addSink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__addSink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__addSink);
		if (size)
			*size = sizeof(struct zkmcu__addSink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__addSink, n);
		if (size)
			*size = n * sizeof(struct zkmcu__addSink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__addSink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__addSink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__addSink %p -> %p\n", q, p));
	*(struct zkmcu__addSink*)p = *(struct zkmcu__addSink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__AddSinkResponse(struct soap *soap, struct zkmcu__AddSinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->sinkid);
	soap_default_string(soap, &a->reason);
	soap_default_zkmcu__MediaEndPoint(soap, &a->media);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__AddSinkResponse(struct soap *soap, const struct zkmcu__AddSinkResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->sinkid, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->reason);
	soap_serialize_zkmcu__MediaEndPoint(soap, &a->media);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__AddSinkResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__AddSinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__AddSinkResponse), type))
		return soap->error;
	if (soap_out_int(soap, "sinkid", -1, &a->sinkid, ""))
		return soap->error;
	if (soap_out_string(soap, "reason", -1, &a->reason, ""))
		return soap->error;
	if (soap_out_zkmcu__MediaEndPoint(soap, "media", -1, &a->media, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__AddSinkResponse * SOAP_FMAC4 soap_in_zkmcu__AddSinkResponse(struct soap *soap, const char *tag, struct zkmcu__AddSinkResponse *a, const char *type)
{
	size_t soap_flag_sinkid = 1;
	size_t soap_flag_reason = 0;
	size_t soap_flag_media = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__AddSinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__AddSinkResponse, sizeof(struct zkmcu__AddSinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__AddSinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sinkid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sinkid", &a->sinkid, "xsd:int"))
				{	soap_flag_sinkid--;
					continue;
				}
			if (soap_flag_reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reason", &a->reason, "xsd:string"))
				{	soap_flag_reason--;
					continue;
				}
			if (soap_flag_media && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_zkmcu__MediaEndPoint(soap, "media", &a->media, "zkmcu:MediaEndPoint"))
				{	soap_flag_media--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddSinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__AddSinkResponse, 0, sizeof(struct zkmcu__AddSinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sinkid > 0 || soap_flag_media > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__AddSinkResponse(struct soap *soap, const struct zkmcu__AddSinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__AddSinkResponse);
	if (soap_out_zkmcu__AddSinkResponse(soap, tag?tag:"zkmcu:AddSinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddSinkResponse * SOAP_FMAC4 soap_get_zkmcu__AddSinkResponse(struct soap *soap, struct zkmcu__AddSinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__AddSinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__AddSinkResponse * SOAP_FMAC2 soap_instantiate_zkmcu__AddSinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__AddSinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__AddSinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__AddSinkResponse);
		if (size)
			*size = sizeof(struct zkmcu__AddSinkResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__AddSinkResponse, n);
		if (size)
			*size = n * sizeof(struct zkmcu__AddSinkResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__AddSinkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__AddSinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__AddSinkResponse %p -> %p\n", q, p));
	*(struct zkmcu__AddSinkResponse*)p = *(struct zkmcu__AddSinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__AddSinkRequest(struct soap *soap, struct zkmcu__AddSinkRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->payload);
	soap_default_string(soap, &a->desc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__AddSinkRequest(struct soap *soap, const struct zkmcu__AddSinkRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->payload, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__AddSinkRequest(struct soap *soap, const char *tag, int id, const struct zkmcu__AddSinkRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__AddSinkRequest), type))
		return soap->error;
	if (soap_out_int(soap, "payload", -1, &a->payload, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__AddSinkRequest * SOAP_FMAC4 soap_in_zkmcu__AddSinkRequest(struct soap *soap, const char *tag, struct zkmcu__AddSinkRequest *a, const char *type)
{
	size_t soap_flag_payload = 1;
	size_t soap_flag_desc = 0;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__AddSinkRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__AddSinkRequest, sizeof(struct zkmcu__AddSinkRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__AddSinkRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_payload && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "payload", &a->payload, "xsd:int"))
				{	soap_flag_payload--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddSinkRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__AddSinkRequest, 0, sizeof(struct zkmcu__AddSinkRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_payload > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__AddSinkRequest(struct soap *soap, const struct zkmcu__AddSinkRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__AddSinkRequest);
	if (soap_out_zkmcu__AddSinkRequest(soap, tag?tag:"zkmcu:AddSinkRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddSinkRequest * SOAP_FMAC4 soap_get_zkmcu__AddSinkRequest(struct soap *soap, struct zkmcu__AddSinkRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__AddSinkRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__AddSinkRequest * SOAP_FMAC2 soap_instantiate_zkmcu__AddSinkRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__AddSinkRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__AddSinkRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__AddSinkRequest);
		if (size)
			*size = sizeof(struct zkmcu__AddSinkRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__AddSinkRequest, n);
		if (size)
			*size = n * sizeof(struct zkmcu__AddSinkRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__AddSinkRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__AddSinkRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__AddSinkRequest %p -> %p\n", q, p));
	*(struct zkmcu__AddSinkRequest*)p = *(struct zkmcu__AddSinkRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__delSource(struct soap *soap, struct zkmcu__delSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	soap_default_int(soap, &a->sourceid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__delSource(struct soap *soap, const struct zkmcu__delSource *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_embedded(soap, &a->sourceid, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__delSource(struct soap *soap, const char *tag, int id, const struct zkmcu__delSource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__delSource), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_int(soap, "sourceid", -1, &a->sourceid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__delSource * SOAP_FMAC4 soap_in_zkmcu__delSource(struct soap *soap, const char *tag, struct zkmcu__delSource *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_sourceid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__delSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__delSource, sizeof(struct zkmcu__delSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__delSource(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_sourceid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sourceid", &a->sourceid, "xsd:int"))
				{	soap_flag_sourceid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__delSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__delSource, 0, sizeof(struct zkmcu__delSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0 || soap_flag_sourceid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__delSource(struct soap *soap, const struct zkmcu__delSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__delSource);
	if (soap_out_zkmcu__delSource(soap, tag?tag:"zkmcu:delSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__delSource * SOAP_FMAC4 soap_get_zkmcu__delSource(struct soap *soap, struct zkmcu__delSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__delSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__delSource * SOAP_FMAC2 soap_instantiate_zkmcu__delSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__delSource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__delSource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__delSource);
		if (size)
			*size = sizeof(struct zkmcu__delSource);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__delSource, n);
		if (size)
			*size = n * sizeof(struct zkmcu__delSource);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__delSource*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__delSource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__delSource %p -> %p\n", q, p));
	*(struct zkmcu__delSource*)p = *(struct zkmcu__delSource*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__addSource(struct soap *soap, struct zkmcu__addSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	a->req = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__addSource(struct soap *soap, const struct zkmcu__addSource *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_serialize_PointerTozkmcu__AddSourceRequest(soap, &a->req);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__addSource(struct soap *soap, const char *tag, int id, const struct zkmcu__addSource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__addSource), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__AddSourceRequest(soap, "req", -1, &a->req, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__addSource * SOAP_FMAC4 soap_in_zkmcu__addSource(struct soap *soap, const char *tag, struct zkmcu__addSource *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_req = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__addSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__addSource, sizeof(struct zkmcu__addSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__addSource(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_req && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__AddSourceRequest(soap, "req", &a->req, "zkmcu:AddSourceRequest"))
				{	soap_flag_req--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__addSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__addSource, 0, sizeof(struct zkmcu__addSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__addSource(struct soap *soap, const struct zkmcu__addSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__addSource);
	if (soap_out_zkmcu__addSource(soap, tag?tag:"zkmcu:addSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__addSource * SOAP_FMAC4 soap_get_zkmcu__addSource(struct soap *soap, struct zkmcu__addSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__addSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__addSource * SOAP_FMAC2 soap_instantiate_zkmcu__addSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__addSource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__addSource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__addSource);
		if (size)
			*size = sizeof(struct zkmcu__addSource);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__addSource, n);
		if (size)
			*size = n * sizeof(struct zkmcu__addSource);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__addSource*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__addSource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__addSource %p -> %p\n", q, p));
	*(struct zkmcu__addSource*)p = *(struct zkmcu__addSource*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__AddSourceResponse(struct soap *soap, struct zkmcu__AddSourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->sourceid);
	soap_default_string(soap, &a->reason);
	soap_default_zkmcu__MediaEndPoint(soap, &a->media);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__AddSourceResponse(struct soap *soap, const struct zkmcu__AddSourceResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->sourceid, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->reason);
	soap_serialize_zkmcu__MediaEndPoint(soap, &a->media);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__AddSourceResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__AddSourceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__AddSourceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "sourceid", -1, &a->sourceid, ""))
		return soap->error;
	if (soap_out_string(soap, "reason", -1, &a->reason, ""))
		return soap->error;
	if (soap_out_zkmcu__MediaEndPoint(soap, "media", -1, &a->media, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__AddSourceResponse * SOAP_FMAC4 soap_in_zkmcu__AddSourceResponse(struct soap *soap, const char *tag, struct zkmcu__AddSourceResponse *a, const char *type)
{
	size_t soap_flag_sourceid = 1;
	size_t soap_flag_reason = 0;
	size_t soap_flag_media = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__AddSourceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__AddSourceResponse, sizeof(struct zkmcu__AddSourceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__AddSourceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sourceid", &a->sourceid, "xsd:int"))
				{	soap_flag_sourceid--;
					continue;
				}
			if (soap_flag_reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reason", &a->reason, "xsd:string"))
				{	soap_flag_reason--;
					continue;
				}
			if (soap_flag_media && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_zkmcu__MediaEndPoint(soap, "media", &a->media, "zkmcu:MediaEndPoint"))
				{	soap_flag_media--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddSourceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__AddSourceResponse, 0, sizeof(struct zkmcu__AddSourceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceid > 0 || soap_flag_media > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__AddSourceResponse(struct soap *soap, const struct zkmcu__AddSourceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__AddSourceResponse);
	if (soap_out_zkmcu__AddSourceResponse(soap, tag?tag:"zkmcu:AddSourceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddSourceResponse * SOAP_FMAC4 soap_get_zkmcu__AddSourceResponse(struct soap *soap, struct zkmcu__AddSourceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__AddSourceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__AddSourceResponse * SOAP_FMAC2 soap_instantiate_zkmcu__AddSourceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__AddSourceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__AddSourceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__AddSourceResponse);
		if (size)
			*size = sizeof(struct zkmcu__AddSourceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__AddSourceResponse, n);
		if (size)
			*size = n * sizeof(struct zkmcu__AddSourceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__AddSourceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__AddSourceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__AddSourceResponse %p -> %p\n", q, p));
	*(struct zkmcu__AddSourceResponse*)p = *(struct zkmcu__AddSourceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__AddSourceRequest(struct soap *soap, struct zkmcu__AddSourceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->payload);
	soap_default_string(soap, &a->desc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__AddSourceRequest(struct soap *soap, const struct zkmcu__AddSourceRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->payload, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__AddSourceRequest(struct soap *soap, const char *tag, int id, const struct zkmcu__AddSourceRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__AddSourceRequest), type))
		return soap->error;
	if (soap_out_int(soap, "payload", -1, &a->payload, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__AddSourceRequest * SOAP_FMAC4 soap_in_zkmcu__AddSourceRequest(struct soap *soap, const char *tag, struct zkmcu__AddSourceRequest *a, const char *type)
{
	size_t soap_flag_payload = 1;
	size_t soap_flag_desc = 0;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__AddSourceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__AddSourceRequest, sizeof(struct zkmcu__AddSourceRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__AddSourceRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_payload && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "payload", &a->payload, "xsd:int"))
				{	soap_flag_payload--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddSourceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__AddSourceRequest, 0, sizeof(struct zkmcu__AddSourceRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_payload > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__AddSourceRequest(struct soap *soap, const struct zkmcu__AddSourceRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__AddSourceRequest);
	if (soap_out_zkmcu__AddSourceRequest(soap, tag?tag:"zkmcu:AddSourceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddSourceRequest * SOAP_FMAC4 soap_get_zkmcu__AddSourceRequest(struct soap *soap, struct zkmcu__AddSourceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__AddSourceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__AddSourceRequest * SOAP_FMAC2 soap_instantiate_zkmcu__AddSourceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__AddSourceRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__AddSourceRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__AddSourceRequest);
		if (size)
			*size = sizeof(struct zkmcu__AddSourceRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__AddSourceRequest, n);
		if (size)
			*size = n * sizeof(struct zkmcu__AddSourceRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__AddSourceRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__AddSourceRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__AddSourceRequest %p -> %p\n", q, p));
	*(struct zkmcu__AddSourceRequest*)p = *(struct zkmcu__AddSourceRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__MediaEndPoint(struct soap *soap, struct zkmcu__MediaEndPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->rtp_USCOREport);
	soap_default_int(soap, &a->rtcp_USCOREport);
	soap_default_string(soap, &a->server_USCOREip);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__MediaEndPoint(struct soap *soap, const struct zkmcu__MediaEndPoint *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->rtp_USCOREport, SOAP_TYPE_int);
	soap_embedded(soap, &a->rtcp_USCOREport, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->server_USCOREip);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__MediaEndPoint(struct soap *soap, const char *tag, int id, const struct zkmcu__MediaEndPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__MediaEndPoint), type))
		return soap->error;
	if (soap_out_int(soap, "rtp_port", -1, &a->rtp_USCOREport, ""))
		return soap->error;
	if (soap_out_int(soap, "rtcp_port", -1, &a->rtcp_USCOREport, ""))
		return soap->error;
	if (soap_out_string(soap, "server_ip", -1, &a->server_USCOREip, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__MediaEndPoint * SOAP_FMAC4 soap_in_zkmcu__MediaEndPoint(struct soap *soap, const char *tag, struct zkmcu__MediaEndPoint *a, const char *type)
{
	size_t soap_flag_rtp_USCOREport = 1;
	size_t soap_flag_rtcp_USCOREport = 1;
	size_t soap_flag_server_USCOREip = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__MediaEndPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__MediaEndPoint, sizeof(struct zkmcu__MediaEndPoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__MediaEndPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_rtp_USCOREport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "rtp_port", &a->rtp_USCOREport, "xsd:int"))
				{	soap_flag_rtp_USCOREport--;
					continue;
				}
			if (soap_flag_rtcp_USCOREport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "rtcp_port", &a->rtcp_USCOREport, "xsd:int"))
				{	soap_flag_rtcp_USCOREport--;
					continue;
				}
			if (soap_flag_server_USCOREip && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "server_ip", &a->server_USCOREip, "xsd:string"))
				{	soap_flag_server_USCOREip--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__MediaEndPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__MediaEndPoint, 0, sizeof(struct zkmcu__MediaEndPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_rtp_USCOREport > 0 || soap_flag_rtcp_USCOREport > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__MediaEndPoint(struct soap *soap, const struct zkmcu__MediaEndPoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__MediaEndPoint);
	if (soap_out_zkmcu__MediaEndPoint(soap, tag?tag:"zkmcu:MediaEndPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__MediaEndPoint * SOAP_FMAC4 soap_get_zkmcu__MediaEndPoint(struct soap *soap, struct zkmcu__MediaEndPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__MediaEndPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__MediaEndPoint * SOAP_FMAC2 soap_instantiate_zkmcu__MediaEndPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__MediaEndPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__MediaEndPoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__MediaEndPoint);
		if (size)
			*size = sizeof(struct zkmcu__MediaEndPoint);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__MediaEndPoint, n);
		if (size)
			*size = n * sizeof(struct zkmcu__MediaEndPoint);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__MediaEndPoint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__MediaEndPoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__MediaEndPoint %p -> %p\n", q, p));
	*(struct zkmcu__MediaEndPoint*)p = *(struct zkmcu__MediaEndPoint*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__infoConference(struct soap *soap, struct zkmcu__infoConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__infoConference(struct soap *soap, const struct zkmcu__infoConference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__infoConference(struct soap *soap, const char *tag, int id, const struct zkmcu__infoConference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__infoConference), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__infoConference * SOAP_FMAC4 soap_in_zkmcu__infoConference(struct soap *soap, const char *tag, struct zkmcu__infoConference *a, const char *type)
{
	size_t soap_flag_cid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__infoConference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__infoConference, sizeof(struct zkmcu__infoConference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__infoConference(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__infoConference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__infoConference, 0, sizeof(struct zkmcu__infoConference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__infoConference(struct soap *soap, const struct zkmcu__infoConference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__infoConference);
	if (soap_out_zkmcu__infoConference(soap, tag?tag:"zkmcu:infoConference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__infoConference * SOAP_FMAC4 soap_get_zkmcu__infoConference(struct soap *soap, struct zkmcu__infoConference *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__infoConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__infoConference * SOAP_FMAC2 soap_instantiate_zkmcu__infoConference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__infoConference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__infoConference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__infoConference);
		if (size)
			*size = sizeof(struct zkmcu__infoConference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__infoConference, n);
		if (size)
			*size = n * sizeof(struct zkmcu__infoConference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__infoConference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__infoConference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__infoConference %p -> %p\n", q, p));
	*(struct zkmcu__infoConference*)p = *(struct zkmcu__infoConference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__ConferenceInfoResponse(struct soap *soap, const struct zkmcu__ConferenceInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_embedded(soap, &a->mode, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
	soap_serialize_PointerTozkmcu__StreamInfoArray(soap, &a->streams);
	soap_serialize_PointerTozkmcu__SourceInfoArray(soap, &a->sources);
	soap_serialize_PointerTozkmcu__SinkInfoArray(soap, &a->sinks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__ConferenceInfoResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__ConferenceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__ConferenceInfoResponse), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_int(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	if (soap_out_double(soap, "uptime", -1, &a->uptime, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__StreamInfoArray(soap, "streams", -1, &a->streams, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__SourceInfoArray(soap, "sources", -1, &a->sources, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__SinkInfoArray(soap, "sinks", -1, &a->sinks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__ConferenceInfo * SOAP_FMAC4 soap_in_zkmcu__ConferenceInfoResponse(struct soap *soap, const char *tag, struct zkmcu__ConferenceInfo *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_mode = 1;
	size_t soap_flag_uptime = 1;
	size_t soap_flag_desc = 1;
	size_t soap_flag_streams = 1;
	size_t soap_flag_sources = 1;
	size_t soap_flag_sinks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__ConferenceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__ConferenceInfoResponse, sizeof(struct zkmcu__ConferenceInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__ConferenceInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mode", &a->mode, "xsd:int"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap_flag_uptime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "uptime", &a->uptime, "xsd:double"))
				{	soap_flag_uptime--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap_flag_streams && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__StreamInfoArray(soap, "streams", &a->streams, "zkmcu:StreamInfoArray"))
				{	soap_flag_streams--;
					continue;
				}
			if (soap_flag_sources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__SourceInfoArray(soap, "sources", &a->sources, "zkmcu:SourceInfoArray"))
				{	soap_flag_sources--;
					continue;
				}
			if (soap_flag_sinks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__SinkInfoArray(soap, "sinks", &a->sinks, "zkmcu:SinkInfoArray"))
				{	soap_flag_sinks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__ConferenceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__ConferenceInfoResponse, 0, sizeof(struct zkmcu__ConferenceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0 || soap_flag_mode > 0 || soap_flag_uptime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__ConferenceInfoResponse(struct soap *soap, const struct zkmcu__ConferenceInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__ConferenceInfoResponse);
	if (soap_out_zkmcu__ConferenceInfoResponse(soap, tag?tag:"zkmcu:ConferenceInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__ConferenceInfo * SOAP_FMAC4 soap_get_zkmcu__ConferenceInfoResponse(struct soap *soap, struct zkmcu__ConferenceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__ConferenceInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__ConferenceInfo(struct soap *soap, struct zkmcu__ConferenceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	soap_default_int(soap, &a->mode);
	soap_default_double(soap, &a->uptime);
	soap_default_string(soap, &a->desc);
	a->streams = NULL;
	a->sources = NULL;
	a->sinks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__ConferenceInfo(struct soap *soap, const struct zkmcu__ConferenceInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_embedded(soap, &a->mode, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
	soap_serialize_PointerTozkmcu__StreamInfoArray(soap, &a->streams);
	soap_serialize_PointerTozkmcu__SourceInfoArray(soap, &a->sources);
	soap_serialize_PointerTozkmcu__SinkInfoArray(soap, &a->sinks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__ConferenceInfo(struct soap *soap, const char *tag, int id, const struct zkmcu__ConferenceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__ConferenceInfo), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_int(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	if (soap_out_double(soap, "uptime", -1, &a->uptime, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__StreamInfoArray(soap, "streams", -1, &a->streams, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__SourceInfoArray(soap, "sources", -1, &a->sources, ""))
		return soap->error;
	if (soap_out_PointerTozkmcu__SinkInfoArray(soap, "sinks", -1, &a->sinks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__ConferenceInfo * SOAP_FMAC4 soap_in_zkmcu__ConferenceInfo(struct soap *soap, const char *tag, struct zkmcu__ConferenceInfo *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_mode = 1;
	size_t soap_flag_uptime = 1;
	size_t soap_flag_desc = 1;
	size_t soap_flag_streams = 1;
	size_t soap_flag_sources = 1;
	size_t soap_flag_sinks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__ConferenceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__ConferenceInfo, sizeof(struct zkmcu__ConferenceInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__ConferenceInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mode", &a->mode, "xsd:int"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap_flag_uptime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "uptime", &a->uptime, "xsd:double"))
				{	soap_flag_uptime--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap_flag_streams && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__StreamInfoArray(soap, "streams", &a->streams, "zkmcu:StreamInfoArray"))
				{	soap_flag_streams--;
					continue;
				}
			if (soap_flag_sources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__SourceInfoArray(soap, "sources", &a->sources, "zkmcu:SourceInfoArray"))
				{	soap_flag_sources--;
					continue;
				}
			if (soap_flag_sinks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__SinkInfoArray(soap, "sinks", &a->sinks, "zkmcu:SinkInfoArray"))
				{	soap_flag_sinks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__ConferenceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__ConferenceInfo, 0, sizeof(struct zkmcu__ConferenceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0 || soap_flag_mode > 0 || soap_flag_uptime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__ConferenceInfo(struct soap *soap, const struct zkmcu__ConferenceInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__ConferenceInfo);
	if (soap_out_zkmcu__ConferenceInfo(soap, tag?tag:"zkmcu:ConferenceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__ConferenceInfo * SOAP_FMAC4 soap_get_zkmcu__ConferenceInfo(struct soap *soap, struct zkmcu__ConferenceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__ConferenceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__ConferenceInfo * SOAP_FMAC2 soap_instantiate_zkmcu__ConferenceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__ConferenceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__ConferenceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__ConferenceInfo);
		if (size)
			*size = sizeof(struct zkmcu__ConferenceInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__ConferenceInfo, n);
		if (size)
			*size = n * sizeof(struct zkmcu__ConferenceInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__ConferenceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__ConferenceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__ConferenceInfo %p -> %p\n", q, p));
	*(struct zkmcu__ConferenceInfo*)p = *(struct zkmcu__ConferenceInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__SinkInfoArray(struct soap *soap, struct zkmcu__SinkInfoArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__SinkInfoArray(struct soap *soap, struct zkmcu__SinkInfoArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_zkmcu__SinkInfoArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_zkmcu__SinkInfo);
			soap_serialize_zkmcu__SinkInfo(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__SinkInfoArray(struct soap *soap, const char *tag, int id, const struct zkmcu__SinkInfoArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_zkmcu__SinkInfoArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_zkmcu__SinkInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__SinkInfoArray * SOAP_FMAC4 soap_in_zkmcu__SinkInfoArray(struct soap *soap, const char *tag, struct zkmcu__SinkInfoArray *a, const char *type)
{	int i, j;
	struct zkmcu__SinkInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "zkmcu:SinkInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct zkmcu__SinkInfoArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__SinkInfoArray, sizeof(struct zkmcu__SinkInfoArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__SinkInfoArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_zkmcu__SinkInfo(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_zkmcu__SinkInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_zkmcu__SinkInfo(soap, NULL, a->__ptr + i, "zkmcu:SinkInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct zkmcu__SinkInfo *)soap_push_block(soap, NULL, sizeof(struct zkmcu__SinkInfo));
				if (!p)
					return NULL;
				SOAP_PLACEMENT_NEW(p, struct zkmcu__SinkInfo);
				soap_default_zkmcu__SinkInfo(soap, p);
				if (!soap_in_zkmcu__SinkInfo(soap, NULL, p, "zkmcu:SinkInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_zkmcu__SinkInfo(soap, soap->blist->size/sizeof(struct zkmcu__SinkInfo));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SinkInfoArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__SinkInfoArray, 0, sizeof(struct zkmcu__SinkInfoArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__SinkInfoArray(struct soap *soap, const struct zkmcu__SinkInfoArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_zkmcu__SinkInfoArray);
	if (soap_out_zkmcu__SinkInfoArray(soap, tag?tag:"zkmcu:SinkInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SinkInfoArray * SOAP_FMAC4 soap_get_zkmcu__SinkInfoArray(struct soap *soap, struct zkmcu__SinkInfoArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__SinkInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__SinkInfoArray * SOAP_FMAC2 soap_instantiate_zkmcu__SinkInfoArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__SinkInfoArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__SinkInfoArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__SinkInfoArray);
		if (size)
			*size = sizeof(struct zkmcu__SinkInfoArray);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__SinkInfoArray, n);
		if (size)
			*size = n * sizeof(struct zkmcu__SinkInfoArray);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__SinkInfoArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__SinkInfoArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__SinkInfoArray %p -> %p\n", q, p));
	*(struct zkmcu__SinkInfoArray*)p = *(struct zkmcu__SinkInfoArray*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__SinkInfo(struct soap *soap, struct zkmcu__SinkInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->sinkid);
	soap_default_string(soap, &a->desc);
	soap_default_long(soap, &a->sent);
	soap_default_long(soap, &a->lost);
	soap_default_int(soap, &a->jitter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__SinkInfo(struct soap *soap, const struct zkmcu__SinkInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->sinkid, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
	soap_embedded(soap, &a->jitter, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__SinkInfo(struct soap *soap, const char *tag, int id, const struct zkmcu__SinkInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__SinkInfo), type))
		return soap->error;
	if (soap_out_int(soap, "sinkid", -1, &a->sinkid, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	if (soap_out_long(soap, "sent", -1, &a->sent, ""))
		return soap->error;
	if (soap_out_long(soap, "lost", -1, &a->lost, ""))
		return soap->error;
	if (soap_out_int(soap, "jitter", -1, &a->jitter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__SinkInfo * SOAP_FMAC4 soap_in_zkmcu__SinkInfo(struct soap *soap, const char *tag, struct zkmcu__SinkInfo *a, const char *type)
{
	size_t soap_flag_sinkid = 1;
	size_t soap_flag_desc = 1;
	size_t soap_flag_sent = 1;
	size_t soap_flag_lost = 1;
	size_t soap_flag_jitter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__SinkInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__SinkInfo, sizeof(struct zkmcu__SinkInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__SinkInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sinkid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sinkid", &a->sinkid, "xsd:int"))
				{	soap_flag_sinkid--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap_flag_sent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "sent", &a->sent, "xsd:long"))
				{	soap_flag_sent--;
					continue;
				}
			if (soap_flag_lost && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "lost", &a->lost, "xsd:long"))
				{	soap_flag_lost--;
					continue;
				}
			if (soap_flag_jitter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "jitter", &a->jitter, "xsd:int"))
				{	soap_flag_jitter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SinkInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__SinkInfo, 0, sizeof(struct zkmcu__SinkInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sinkid > 0 || soap_flag_sent > 0 || soap_flag_lost > 0 || soap_flag_jitter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__SinkInfo(struct soap *soap, const struct zkmcu__SinkInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__SinkInfo);
	if (soap_out_zkmcu__SinkInfo(soap, tag?tag:"zkmcu:SinkInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SinkInfo * SOAP_FMAC4 soap_get_zkmcu__SinkInfo(struct soap *soap, struct zkmcu__SinkInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__SinkInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__SinkInfo * SOAP_FMAC2 soap_instantiate_zkmcu__SinkInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__SinkInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__SinkInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__SinkInfo);
		if (size)
			*size = sizeof(struct zkmcu__SinkInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__SinkInfo, n);
		if (size)
			*size = n * sizeof(struct zkmcu__SinkInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__SinkInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__SinkInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__SinkInfo %p -> %p\n", q, p));
	*(struct zkmcu__SinkInfo*)p = *(struct zkmcu__SinkInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__SourceInfoArray(struct soap *soap, struct zkmcu__SourceInfoArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__SourceInfoArray(struct soap *soap, struct zkmcu__SourceInfoArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_zkmcu__SourceInfoArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_zkmcu__SourceInfo);
			soap_serialize_zkmcu__SourceInfo(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__SourceInfoArray(struct soap *soap, const char *tag, int id, const struct zkmcu__SourceInfoArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_zkmcu__SourceInfoArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_zkmcu__SourceInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__SourceInfoArray * SOAP_FMAC4 soap_in_zkmcu__SourceInfoArray(struct soap *soap, const char *tag, struct zkmcu__SourceInfoArray *a, const char *type)
{	int i, j;
	struct zkmcu__SourceInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "zkmcu:SourceInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct zkmcu__SourceInfoArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__SourceInfoArray, sizeof(struct zkmcu__SourceInfoArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__SourceInfoArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_zkmcu__SourceInfo(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_zkmcu__SourceInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_zkmcu__SourceInfo(soap, NULL, a->__ptr + i, "zkmcu:SourceInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct zkmcu__SourceInfo *)soap_push_block(soap, NULL, sizeof(struct zkmcu__SourceInfo));
				if (!p)
					return NULL;
				SOAP_PLACEMENT_NEW(p, struct zkmcu__SourceInfo);
				soap_default_zkmcu__SourceInfo(soap, p);
				if (!soap_in_zkmcu__SourceInfo(soap, NULL, p, "zkmcu:SourceInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_zkmcu__SourceInfo(soap, soap->blist->size/sizeof(struct zkmcu__SourceInfo));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SourceInfoArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__SourceInfoArray, 0, sizeof(struct zkmcu__SourceInfoArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__SourceInfoArray(struct soap *soap, const struct zkmcu__SourceInfoArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_zkmcu__SourceInfoArray);
	if (soap_out_zkmcu__SourceInfoArray(soap, tag?tag:"zkmcu:SourceInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SourceInfoArray * SOAP_FMAC4 soap_get_zkmcu__SourceInfoArray(struct soap *soap, struct zkmcu__SourceInfoArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__SourceInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__SourceInfoArray * SOAP_FMAC2 soap_instantiate_zkmcu__SourceInfoArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__SourceInfoArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__SourceInfoArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__SourceInfoArray);
		if (size)
			*size = sizeof(struct zkmcu__SourceInfoArray);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__SourceInfoArray, n);
		if (size)
			*size = n * sizeof(struct zkmcu__SourceInfoArray);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__SourceInfoArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__SourceInfoArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__SourceInfoArray %p -> %p\n", q, p));
	*(struct zkmcu__SourceInfoArray*)p = *(struct zkmcu__SourceInfoArray*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__SourceInfo(struct soap *soap, struct zkmcu__SourceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->sourceid);
	soap_default_string(soap, &a->desc);
	soap_default_long(soap, &a->lost);
	soap_default_long(soap, &a->recv);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__SourceInfo(struct soap *soap, const struct zkmcu__SourceInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->sourceid, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__SourceInfo(struct soap *soap, const char *tag, int id, const struct zkmcu__SourceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__SourceInfo), type))
		return soap->error;
	if (soap_out_int(soap, "sourceid", -1, &a->sourceid, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	if (soap_out_long(soap, "lost", -1, &a->lost, ""))
		return soap->error;
	if (soap_out_long(soap, "recv", -1, &a->recv, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__SourceInfo * SOAP_FMAC4 soap_in_zkmcu__SourceInfo(struct soap *soap, const char *tag, struct zkmcu__SourceInfo *a, const char *type)
{
	size_t soap_flag_sourceid = 1;
	size_t soap_flag_desc = 1;
	size_t soap_flag_lost = 1;
	size_t soap_flag_recv = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__SourceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__SourceInfo, sizeof(struct zkmcu__SourceInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__SourceInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sourceid", &a->sourceid, "xsd:int"))
				{	soap_flag_sourceid--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap_flag_lost && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "lost", &a->lost, "xsd:long"))
				{	soap_flag_lost--;
					continue;
				}
			if (soap_flag_recv && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "recv", &a->recv, "xsd:long"))
				{	soap_flag_recv--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SourceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__SourceInfo, 0, sizeof(struct zkmcu__SourceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceid > 0 || soap_flag_lost > 0 || soap_flag_recv > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__SourceInfo(struct soap *soap, const struct zkmcu__SourceInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__SourceInfo);
	if (soap_out_zkmcu__SourceInfo(soap, tag?tag:"zkmcu:SourceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SourceInfo * SOAP_FMAC4 soap_get_zkmcu__SourceInfo(struct soap *soap, struct zkmcu__SourceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__SourceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__SourceInfo * SOAP_FMAC2 soap_instantiate_zkmcu__SourceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__SourceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__SourceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__SourceInfo);
		if (size)
			*size = sizeof(struct zkmcu__SourceInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__SourceInfo, n);
		if (size)
			*size = n * sizeof(struct zkmcu__SourceInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__SourceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__SourceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__SourceInfo %p -> %p\n", q, p));
	*(struct zkmcu__SourceInfo*)p = *(struct zkmcu__SourceInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__StreamInfoArray(struct soap *soap, struct zkmcu__StreamInfoArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__StreamInfoArray(struct soap *soap, struct zkmcu__StreamInfoArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_zkmcu__StreamInfoArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_zkmcu__StreamInfo);
			soap_serialize_zkmcu__StreamInfo(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__StreamInfoArray(struct soap *soap, const char *tag, int id, const struct zkmcu__StreamInfoArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_zkmcu__StreamInfoArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_zkmcu__StreamInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__StreamInfoArray * SOAP_FMAC4 soap_in_zkmcu__StreamInfoArray(struct soap *soap, const char *tag, struct zkmcu__StreamInfoArray *a, const char *type)
{	int i, j;
	struct zkmcu__StreamInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "zkmcu:StreamInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct zkmcu__StreamInfoArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__StreamInfoArray, sizeof(struct zkmcu__StreamInfoArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__StreamInfoArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_zkmcu__StreamInfo(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_zkmcu__StreamInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_zkmcu__StreamInfo(soap, NULL, a->__ptr + i, "zkmcu:StreamInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct zkmcu__StreamInfo *)soap_push_block(soap, NULL, sizeof(struct zkmcu__StreamInfo));
				if (!p)
					return NULL;
				SOAP_PLACEMENT_NEW(p, struct zkmcu__StreamInfo);
				soap_default_zkmcu__StreamInfo(soap, p);
				if (!soap_in_zkmcu__StreamInfo(soap, NULL, p, "zkmcu:StreamInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_zkmcu__StreamInfo(soap, soap->blist->size/sizeof(struct zkmcu__StreamInfo));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__StreamInfoArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__StreamInfoArray, 0, sizeof(struct zkmcu__StreamInfoArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__StreamInfoArray(struct soap *soap, const struct zkmcu__StreamInfoArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_zkmcu__StreamInfoArray);
	if (soap_out_zkmcu__StreamInfoArray(soap, tag?tag:"zkmcu:StreamInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__StreamInfoArray * SOAP_FMAC4 soap_get_zkmcu__StreamInfoArray(struct soap *soap, struct zkmcu__StreamInfoArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__StreamInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__StreamInfoArray * SOAP_FMAC2 soap_instantiate_zkmcu__StreamInfoArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__StreamInfoArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__StreamInfoArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__StreamInfoArray);
		if (size)
			*size = sizeof(struct zkmcu__StreamInfoArray);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__StreamInfoArray, n);
		if (size)
			*size = n * sizeof(struct zkmcu__StreamInfoArray);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__StreamInfoArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__StreamInfoArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__StreamInfoArray %p -> %p\n", q, p));
	*(struct zkmcu__StreamInfoArray*)p = *(struct zkmcu__StreamInfoArray*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__StreamInfo(struct soap *soap, struct zkmcu__StreamInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->streamid);
	soap_default_string(soap, &a->desc);
	soap_default_long(soap, &a->sent);
	soap_default_long(soap, &a->recv);
	soap_default_long(soap, &a->lost_USCOREsent);
	soap_default_long(soap, &a->lost_USCORErecv);
	soap_default_int(soap, &a->jitter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__StreamInfo(struct soap *soap, const struct zkmcu__StreamInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->streamid, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
	soap_embedded(soap, &a->jitter, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__StreamInfo(struct soap *soap, const char *tag, int id, const struct zkmcu__StreamInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__StreamInfo), type))
		return soap->error;
	if (soap_out_int(soap, "streamid", -1, &a->streamid, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	if (soap_out_long(soap, "sent", -1, &a->sent, ""))
		return soap->error;
	if (soap_out_long(soap, "recv", -1, &a->recv, ""))
		return soap->error;
	if (soap_out_long(soap, "lost_sent", -1, &a->lost_USCOREsent, ""))
		return soap->error;
	if (soap_out_long(soap, "lost_recv", -1, &a->lost_USCORErecv, ""))
		return soap->error;
	if (soap_out_int(soap, "jitter", -1, &a->jitter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__StreamInfo * SOAP_FMAC4 soap_in_zkmcu__StreamInfo(struct soap *soap, const char *tag, struct zkmcu__StreamInfo *a, const char *type)
{
	size_t soap_flag_streamid = 1;
	size_t soap_flag_desc = 1;
	size_t soap_flag_sent = 1;
	size_t soap_flag_recv = 1;
	size_t soap_flag_lost_USCOREsent = 1;
	size_t soap_flag_lost_USCORErecv = 1;
	size_t soap_flag_jitter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__StreamInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__StreamInfo, sizeof(struct zkmcu__StreamInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__StreamInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_streamid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "streamid", &a->streamid, "xsd:int"))
				{	soap_flag_streamid--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap_flag_sent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "sent", &a->sent, "xsd:long"))
				{	soap_flag_sent--;
					continue;
				}
			if (soap_flag_recv && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "recv", &a->recv, "xsd:long"))
				{	soap_flag_recv--;
					continue;
				}
			if (soap_flag_lost_USCOREsent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "lost_sent", &a->lost_USCOREsent, "xsd:long"))
				{	soap_flag_lost_USCOREsent--;
					continue;
				}
			if (soap_flag_lost_USCORErecv && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "lost_recv", &a->lost_USCORErecv, "xsd:long"))
				{	soap_flag_lost_USCORErecv--;
					continue;
				}
			if (soap_flag_jitter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "jitter", &a->jitter, "xsd:int"))
				{	soap_flag_jitter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__StreamInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__StreamInfo, 0, sizeof(struct zkmcu__StreamInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_streamid > 0 || soap_flag_sent > 0 || soap_flag_recv > 0 || soap_flag_lost_USCOREsent > 0 || soap_flag_lost_USCORErecv > 0 || soap_flag_jitter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__StreamInfo(struct soap *soap, const struct zkmcu__StreamInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__StreamInfo);
	if (soap_out_zkmcu__StreamInfo(soap, tag?tag:"zkmcu:StreamInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__StreamInfo * SOAP_FMAC4 soap_get_zkmcu__StreamInfo(struct soap *soap, struct zkmcu__StreamInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__StreamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__StreamInfo * SOAP_FMAC2 soap_instantiate_zkmcu__StreamInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__StreamInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__StreamInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__StreamInfo);
		if (size)
			*size = sizeof(struct zkmcu__StreamInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__StreamInfo, n);
		if (size)
			*size = n * sizeof(struct zkmcu__StreamInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__StreamInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__StreamInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__StreamInfo %p -> %p\n", q, p));
	*(struct zkmcu__StreamInfo*)p = *(struct zkmcu__StreamInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__listConferences(struct soap *soap, struct zkmcu__listConferences *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _param_4 skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__listConferences(struct soap *soap, const struct zkmcu__listConferences *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _param_4 skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__listConferences(struct soap *soap, const char *tag, int id, const struct zkmcu__listConferences *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__listConferences), type))
		return soap->error;
	/* transient _param_4 skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__listConferences * SOAP_FMAC4 soap_in_zkmcu__listConferences(struct soap *soap, const char *tag, struct zkmcu__listConferences *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__listConferences *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__listConferences, sizeof(struct zkmcu__listConferences), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__listConferences(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _param_4 skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__listConferences *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__listConferences, 0, sizeof(struct zkmcu__listConferences), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__listConferences(struct soap *soap, const struct zkmcu__listConferences *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__listConferences);
	if (soap_out_zkmcu__listConferences(soap, tag?tag:"zkmcu:listConferences", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__listConferences * SOAP_FMAC4 soap_get_zkmcu__listConferences(struct soap *soap, struct zkmcu__listConferences *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__listConferences(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__listConferences * SOAP_FMAC2 soap_instantiate_zkmcu__listConferences(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__listConferences(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__listConferences, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__listConferences);
		if (size)
			*size = sizeof(struct zkmcu__listConferences);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__listConferences, n);
		if (size)
			*size = n * sizeof(struct zkmcu__listConferences);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__listConferences*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__listConferences(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__listConferences %p -> %p\n", q, p));
	*(struct zkmcu__listConferences*)p = *(struct zkmcu__listConferences*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__listConferencesResponse(struct soap *soap, struct zkmcu__listConferencesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_zkmcu__ConferenceIdArrayResponse(soap, &a->res);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__listConferencesResponse(struct soap *soap, const struct zkmcu__listConferencesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_zkmcu__ConferenceIdArrayResponse(soap, &a->res);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__listConferencesResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__listConferencesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__listConferencesResponse), type))
		return soap->error;
	if (soap_out_zkmcu__ConferenceIdArrayResponse(soap, "res", -1, &a->res, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__listConferencesResponse * SOAP_FMAC4 soap_in_zkmcu__listConferencesResponse(struct soap *soap, const char *tag, struct zkmcu__listConferencesResponse *a, const char *type)
{
	size_t soap_flag_res = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__listConferencesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__listConferencesResponse, sizeof(struct zkmcu__listConferencesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__listConferencesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_res && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_zkmcu__ConferenceIdArrayResponse(soap, "res", &a->res, "zkmcu:ConferenceIdArrayResponse"))
				{	soap_flag_res--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__listConferencesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__listConferencesResponse, 0, sizeof(struct zkmcu__listConferencesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_res > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__listConferencesResponse(struct soap *soap, const struct zkmcu__listConferencesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__listConferencesResponse);
	if (soap_out_zkmcu__listConferencesResponse(soap, tag?tag:"zkmcu:listConferencesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__listConferencesResponse * SOAP_FMAC4 soap_get_zkmcu__listConferencesResponse(struct soap *soap, struct zkmcu__listConferencesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__listConferencesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__listConferencesResponse * SOAP_FMAC2 soap_instantiate_zkmcu__listConferencesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__listConferencesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__listConferencesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__listConferencesResponse);
		if (size)
			*size = sizeof(struct zkmcu__listConferencesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__listConferencesResponse, n);
		if (size)
			*size = n * sizeof(struct zkmcu__listConferencesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__listConferencesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__listConferencesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__listConferencesResponse %p -> %p\n", q, p));
	*(struct zkmcu__listConferencesResponse*)p = *(struct zkmcu__listConferencesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__ConferenceIdArrayResponse(struct soap *soap, struct zkmcu__ConferenceIdArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_zkmcu__ConferenceIdArrayResponse))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_int);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__ConferenceIdArrayResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__ConferenceIdArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_zkmcu__ConferenceIdArrayResponse);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_int(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__ConferenceIdArray * SOAP_FMAC4 soap_in_zkmcu__ConferenceIdArrayResponse(struct soap *soap, const char *tag, struct zkmcu__ConferenceIdArray *a, const char *type)
{	int i, j;
	int *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "xsd:int") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct zkmcu__ConferenceIdArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__ConferenceIdArrayResponse, sizeof(struct zkmcu__ConferenceIdArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__ConferenceIdArrayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (int *)soap_malloc(soap, sizeof(int) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_int(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_int(soap, NULL, a->__ptr + i, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (int *)soap_push_block(soap, NULL, sizeof(int));
				if (!p)
					return NULL;
				soap_default_int(soap, p);
				if (!soap_in_int(soap, NULL, p, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (int *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__ConferenceIdArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__ConferenceIdArrayResponse, 0, sizeof(struct zkmcu__ConferenceIdArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__ConferenceIdArrayResponse(struct soap *soap, const struct zkmcu__ConferenceIdArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_zkmcu__ConferenceIdArrayResponse);
	if (soap_out_zkmcu__ConferenceIdArrayResponse(soap, tag?tag:"zkmcu:ConferenceIdArrayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__ConferenceIdArray * SOAP_FMAC4 soap_get_zkmcu__ConferenceIdArrayResponse(struct soap *soap, struct zkmcu__ConferenceIdArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__ConferenceIdArrayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__ConferenceIdArray(struct soap *soap, struct zkmcu__ConferenceIdArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__ConferenceIdArray(struct soap *soap, struct zkmcu__ConferenceIdArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_zkmcu__ConferenceIdArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_int);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__ConferenceIdArray(struct soap *soap, const char *tag, int id, const struct zkmcu__ConferenceIdArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_zkmcu__ConferenceIdArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_int(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__ConferenceIdArray * SOAP_FMAC4 soap_in_zkmcu__ConferenceIdArray(struct soap *soap, const char *tag, struct zkmcu__ConferenceIdArray *a, const char *type)
{	int i, j;
	int *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "xsd:int") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct zkmcu__ConferenceIdArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__ConferenceIdArray, sizeof(struct zkmcu__ConferenceIdArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__ConferenceIdArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (int *)soap_malloc(soap, sizeof(int) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_int(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_int(soap, NULL, a->__ptr + i, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (int *)soap_push_block(soap, NULL, sizeof(int));
				if (!p)
					return NULL;
				soap_default_int(soap, p);
				if (!soap_in_int(soap, NULL, p, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (int *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__ConferenceIdArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__ConferenceIdArray, 0, sizeof(struct zkmcu__ConferenceIdArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__ConferenceIdArray(struct soap *soap, const struct zkmcu__ConferenceIdArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_zkmcu__ConferenceIdArray);
	if (soap_out_zkmcu__ConferenceIdArray(soap, tag?tag:"zkmcu:ConferenceIdArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__ConferenceIdArray * SOAP_FMAC4 soap_get_zkmcu__ConferenceIdArray(struct soap *soap, struct zkmcu__ConferenceIdArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__ConferenceIdArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__ConferenceIdArray * SOAP_FMAC2 soap_instantiate_zkmcu__ConferenceIdArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__ConferenceIdArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__ConferenceIdArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__ConferenceIdArray);
		if (size)
			*size = sizeof(struct zkmcu__ConferenceIdArray);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__ConferenceIdArray, n);
		if (size)
			*size = n * sizeof(struct zkmcu__ConferenceIdArray);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__ConferenceIdArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__ConferenceIdArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__ConferenceIdArray %p -> %p\n", q, p));
	*(struct zkmcu__ConferenceIdArray*)p = *(struct zkmcu__ConferenceIdArray*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__destroyConference(struct soap *soap, struct zkmcu__destroyConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__destroyConference(struct soap *soap, const struct zkmcu__destroyConference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__destroyConference(struct soap *soap, const char *tag, int id, const struct zkmcu__destroyConference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__destroyConference), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__destroyConference * SOAP_FMAC4 soap_in_zkmcu__destroyConference(struct soap *soap, const char *tag, struct zkmcu__destroyConference *a, const char *type)
{
	size_t soap_flag_cid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__destroyConference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__destroyConference, sizeof(struct zkmcu__destroyConference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__destroyConference(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__destroyConference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__destroyConference, 0, sizeof(struct zkmcu__destroyConference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__destroyConference(struct soap *soap, const struct zkmcu__destroyConference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__destroyConference);
	if (soap_out_zkmcu__destroyConference(soap, tag?tag:"zkmcu:destroyConference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__destroyConference * SOAP_FMAC4 soap_get_zkmcu__destroyConference(struct soap *soap, struct zkmcu__destroyConference *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__destroyConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__destroyConference * SOAP_FMAC2 soap_instantiate_zkmcu__destroyConference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__destroyConference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__destroyConference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__destroyConference);
		if (size)
			*size = sizeof(struct zkmcu__destroyConference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__destroyConference, n);
		if (size)
			*size = n * sizeof(struct zkmcu__destroyConference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__destroyConference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__destroyConference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__destroyConference %p -> %p\n", q, p));
	*(struct zkmcu__destroyConference*)p = *(struct zkmcu__destroyConference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__createConference(struct soap *soap, struct zkmcu__createConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->req = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__createConference(struct soap *soap, const struct zkmcu__createConference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTozkmcu__CreateConference(soap, &a->req);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__createConference(struct soap *soap, const char *tag, int id, const struct zkmcu__createConference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__createConference), type))
		return soap->error;
	if (soap_out_PointerTozkmcu__CreateConference(soap, "req", -1, &a->req, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__createConference * SOAP_FMAC4 soap_in_zkmcu__createConference(struct soap *soap, const char *tag, struct zkmcu__createConference *a, const char *type)
{
	size_t soap_flag_req = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__createConference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__createConference, sizeof(struct zkmcu__createConference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__createConference(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_req && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTozkmcu__CreateConference(soap, "req", &a->req, "zkmcu:CreateConference"))
				{	soap_flag_req--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__createConference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__createConference, 0, sizeof(struct zkmcu__createConference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__createConference(struct soap *soap, const struct zkmcu__createConference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__createConference);
	if (soap_out_zkmcu__createConference(soap, tag?tag:"zkmcu:createConference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__createConference * SOAP_FMAC4 soap_get_zkmcu__createConference(struct soap *soap, struct zkmcu__createConference *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__createConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__createConference * SOAP_FMAC2 soap_instantiate_zkmcu__createConference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__createConference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__createConference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__createConference);
		if (size)
			*size = sizeof(struct zkmcu__createConference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__createConference, n);
		if (size)
			*size = n * sizeof(struct zkmcu__createConference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__createConference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__createConference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__createConference %p -> %p\n", q, p));
	*(struct zkmcu__createConference*)p = *(struct zkmcu__createConference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__CreateConferenceResponse(struct soap *soap, struct zkmcu__CreateConferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cid);
	soap_default_string(soap, &a->reason);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__CreateConferenceResponse(struct soap *soap, const struct zkmcu__CreateConferenceResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cid, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->reason);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__CreateConferenceResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__CreateConferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__CreateConferenceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->cid, ""))
		return soap->error;
	if (soap_out_string(soap, "reason", -1, &a->reason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__CreateConferenceResponse * SOAP_FMAC4 soap_in_zkmcu__CreateConferenceResponse(struct soap *soap, const char *tag, struct zkmcu__CreateConferenceResponse *a, const char *type)
{
	size_t soap_flag_cid = 1;
	size_t soap_flag_reason = 0;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__CreateConferenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__CreateConferenceResponse, sizeof(struct zkmcu__CreateConferenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__CreateConferenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cid", &a->cid, "xsd:int"))
				{	soap_flag_cid--;
					continue;
				}
			if (soap_flag_reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reason", &a->reason, "xsd:string"))
				{	soap_flag_reason--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__CreateConferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__CreateConferenceResponse, 0, sizeof(struct zkmcu__CreateConferenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__CreateConferenceResponse(struct soap *soap, const struct zkmcu__CreateConferenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__CreateConferenceResponse);
	if (soap_out_zkmcu__CreateConferenceResponse(soap, tag?tag:"zkmcu:CreateConferenceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__CreateConferenceResponse * SOAP_FMAC4 soap_get_zkmcu__CreateConferenceResponse(struct soap *soap, struct zkmcu__CreateConferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__CreateConferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__CreateConferenceResponse * SOAP_FMAC2 soap_instantiate_zkmcu__CreateConferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__CreateConferenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__CreateConferenceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__CreateConferenceResponse);
		if (size)
			*size = sizeof(struct zkmcu__CreateConferenceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__CreateConferenceResponse, n);
		if (size)
			*size = n * sizeof(struct zkmcu__CreateConferenceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__CreateConferenceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__CreateConferenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__CreateConferenceResponse %p -> %p\n", q, p));
	*(struct zkmcu__CreateConferenceResponse*)p = *(struct zkmcu__CreateConferenceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__CreateConference(struct soap *soap, struct zkmcu__CreateConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->mode);
	soap_default_int(soap, &a->livingcast);
	soap_default_string(soap, &a->desc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__CreateConference(struct soap *soap, const struct zkmcu__CreateConference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->mode, SOAP_TYPE_int);
	soap_embedded(soap, &a->livingcast, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->desc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__CreateConference(struct soap *soap, const char *tag, int id, const struct zkmcu__CreateConference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__CreateConference), type))
		return soap->error;
	if (soap_out_int(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	if (soap_out_int(soap, "livingcast", -1, &a->livingcast, ""))
		return soap->error;
	if (soap_out_string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__CreateConference * SOAP_FMAC4 soap_in_zkmcu__CreateConference(struct soap *soap, const char *tag, struct zkmcu__CreateConference *a, const char *type)
{
	size_t soap_flag_mode = 1;
	size_t soap_flag_livingcast = 0;
	size_t soap_flag_desc = 0;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__CreateConference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__CreateConference, sizeof(struct zkmcu__CreateConference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__CreateConference(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mode", &a->mode, "xsd:int"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap_flag_livingcast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "livingcast", &a->livingcast, "xsd:int"))
				{	soap_flag_livingcast--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__CreateConference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__CreateConference, 0, sizeof(struct zkmcu__CreateConference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mode > 0 || soap_flag_livingcast > -1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__CreateConference(struct soap *soap, const struct zkmcu__CreateConference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__CreateConference);
	if (soap_out_zkmcu__CreateConference(soap, tag?tag:"zkmcu:CreateConference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__CreateConference * SOAP_FMAC4 soap_get_zkmcu__CreateConference(struct soap *soap, struct zkmcu__CreateConference *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__CreateConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__CreateConference * SOAP_FMAC2 soap_instantiate_zkmcu__CreateConference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__CreateConference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__CreateConference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__CreateConference);
		if (size)
			*size = sizeof(struct zkmcu__CreateConference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__CreateConference, n);
		if (size)
			*size = n * sizeof(struct zkmcu__CreateConference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__CreateConference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__CreateConference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__CreateConference %p -> %p\n", q, p));
	*(struct zkmcu__CreateConference*)p = *(struct zkmcu__CreateConference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__getSysInfo(struct soap *soap, struct zkmcu__getSysInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _param_2 skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__getSysInfo(struct soap *soap, const struct zkmcu__getSysInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _param_2 skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__getSysInfo(struct soap *soap, const char *tag, int id, const struct zkmcu__getSysInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__getSysInfo), type))
		return soap->error;
	/* transient _param_2 skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__getSysInfo * SOAP_FMAC4 soap_in_zkmcu__getSysInfo(struct soap *soap, const char *tag, struct zkmcu__getSysInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__getSysInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__getSysInfo, sizeof(struct zkmcu__getSysInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__getSysInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _param_2 skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__getSysInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__getSysInfo, 0, sizeof(struct zkmcu__getSysInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__getSysInfo(struct soap *soap, const struct zkmcu__getSysInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__getSysInfo);
	if (soap_out_zkmcu__getSysInfo(soap, tag?tag:"zkmcu:getSysInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__getSysInfo * SOAP_FMAC4 soap_get_zkmcu__getSysInfo(struct soap *soap, struct zkmcu__getSysInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__getSysInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__getSysInfo * SOAP_FMAC2 soap_instantiate_zkmcu__getSysInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__getSysInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__getSysInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__getSysInfo);
		if (size)
			*size = sizeof(struct zkmcu__getSysInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__getSysInfo, n);
		if (size)
			*size = n * sizeof(struct zkmcu__getSysInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__getSysInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__getSysInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__getSysInfo %p -> %p\n", q, p));
	*(struct zkmcu__getSysInfo*)p = *(struct zkmcu__getSysInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__SysInfoResponse(struct soap *soap, const struct zkmcu__SysInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__SysInfoResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__SysInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__SysInfoResponse), type))
		return soap->error;
	if (soap_out_double(soap, "cpu", -1, &a->cpu, ""))
		return soap->error;
	if (soap_out_double(soap, "mem", -1, &a->mem, ""))
		return soap->error;
	if (soap_out_double(soap, "net_sent", -1, &a->net_USCOREsent, ""))
		return soap->error;
	if (soap_out_double(soap, "net_recv", -1, &a->net_USCORErecv, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__SysInfo * SOAP_FMAC4 soap_in_zkmcu__SysInfoResponse(struct soap *soap, const char *tag, struct zkmcu__SysInfo *a, const char *type)
{
	size_t soap_flag_cpu = 1;
	size_t soap_flag_mem = 1;
	size_t soap_flag_net_USCOREsent = 1;
	size_t soap_flag_net_USCORErecv = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__SysInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__SysInfoResponse, sizeof(struct zkmcu__SysInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__SysInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cpu && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "cpu", &a->cpu, "xsd:double"))
				{	soap_flag_cpu--;
					continue;
				}
			if (soap_flag_mem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mem", &a->mem, "xsd:double"))
				{	soap_flag_mem--;
					continue;
				}
			if (soap_flag_net_USCOREsent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "net_sent", &a->net_USCOREsent, "xsd:double"))
				{	soap_flag_net_USCOREsent--;
					continue;
				}
			if (soap_flag_net_USCORErecv && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "net_recv", &a->net_USCORErecv, "xsd:double"))
				{	soap_flag_net_USCORErecv--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SysInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__SysInfoResponse, 0, sizeof(struct zkmcu__SysInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cpu > 0 || soap_flag_mem > 0 || soap_flag_net_USCOREsent > 0 || soap_flag_net_USCORErecv > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__SysInfoResponse(struct soap *soap, const struct zkmcu__SysInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__SysInfoResponse);
	if (soap_out_zkmcu__SysInfoResponse(soap, tag?tag:"zkmcu:SysInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SysInfo * SOAP_FMAC4 soap_get_zkmcu__SysInfoResponse(struct soap *soap, struct zkmcu__SysInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__SysInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__SysInfo(struct soap *soap, struct zkmcu__SysInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->cpu);
	soap_default_double(soap, &a->mem);
	soap_default_double(soap, &a->net_USCOREsent);
	soap_default_double(soap, &a->net_USCORErecv);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__SysInfo(struct soap *soap, const struct zkmcu__SysInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__SysInfo(struct soap *soap, const char *tag, int id, const struct zkmcu__SysInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__SysInfo), type))
		return soap->error;
	if (soap_out_double(soap, "cpu", -1, &a->cpu, ""))
		return soap->error;
	if (soap_out_double(soap, "mem", -1, &a->mem, ""))
		return soap->error;
	if (soap_out_double(soap, "net_sent", -1, &a->net_USCOREsent, ""))
		return soap->error;
	if (soap_out_double(soap, "net_recv", -1, &a->net_USCORErecv, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__SysInfo * SOAP_FMAC4 soap_in_zkmcu__SysInfo(struct soap *soap, const char *tag, struct zkmcu__SysInfo *a, const char *type)
{
	size_t soap_flag_cpu = 1;
	size_t soap_flag_mem = 1;
	size_t soap_flag_net_USCOREsent = 1;
	size_t soap_flag_net_USCORErecv = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__SysInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__SysInfo, sizeof(struct zkmcu__SysInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__SysInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cpu && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "cpu", &a->cpu, "xsd:double"))
				{	soap_flag_cpu--;
					continue;
				}
			if (soap_flag_mem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mem", &a->mem, "xsd:double"))
				{	soap_flag_mem--;
					continue;
				}
			if (soap_flag_net_USCOREsent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "net_sent", &a->net_USCOREsent, "xsd:double"))
				{	soap_flag_net_USCOREsent--;
					continue;
				}
			if (soap_flag_net_USCORErecv && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "net_recv", &a->net_USCORErecv, "xsd:double"))
				{	soap_flag_net_USCORErecv--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SysInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__SysInfo, 0, sizeof(struct zkmcu__SysInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cpu > 0 || soap_flag_mem > 0 || soap_flag_net_USCOREsent > 0 || soap_flag_net_USCORErecv > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__SysInfo(struct soap *soap, const struct zkmcu__SysInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__SysInfo);
	if (soap_out_zkmcu__SysInfo(soap, tag?tag:"zkmcu:SysInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SysInfo * SOAP_FMAC4 soap_get_zkmcu__SysInfo(struct soap *soap, struct zkmcu__SysInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__SysInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__SysInfo * SOAP_FMAC2 soap_instantiate_zkmcu__SysInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__SysInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__SysInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__SysInfo);
		if (size)
			*size = sizeof(struct zkmcu__SysInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__SysInfo, n);
		if (size)
			*size = n * sizeof(struct zkmcu__SysInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__SysInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__SysInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__SysInfo %p -> %p\n", q, p));
	*(struct zkmcu__SysInfo*)p = *(struct zkmcu__SysInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__getVersion(struct soap *soap, struct zkmcu__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _param_1 skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__getVersion(struct soap *soap, const struct zkmcu__getVersion *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _param_1 skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__getVersion(struct soap *soap, const char *tag, int id, const struct zkmcu__getVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__getVersion), type))
		return soap->error;
	/* transient _param_1 skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__getVersion * SOAP_FMAC4 soap_in_zkmcu__getVersion(struct soap *soap, const char *tag, struct zkmcu__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__getVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__getVersion, sizeof(struct zkmcu__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__getVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _param_1 skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__getVersion, 0, sizeof(struct zkmcu__getVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__getVersion(struct soap *soap, const struct zkmcu__getVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__getVersion);
	if (soap_out_zkmcu__getVersion(soap, tag?tag:"zkmcu:getVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__getVersion * SOAP_FMAC4 soap_get_zkmcu__getVersion(struct soap *soap, struct zkmcu__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__getVersion * SOAP_FMAC2 soap_instantiate_zkmcu__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__getVersion);
		if (size)
			*size = sizeof(struct zkmcu__getVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__getVersion, n);
		if (size)
			*size = n * sizeof(struct zkmcu__getVersion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__getVersion %p -> %p\n", q, p));
	*(struct zkmcu__getVersion*)p = *(struct zkmcu__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_zkmcu__getVersionResponse(struct soap *soap, struct zkmcu__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->info = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_zkmcu__getVersionResponse(struct soap *soap, const struct zkmcu__getVersionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->info);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_zkmcu__getVersionResponse(struct soap *soap, const char *tag, int id, const struct zkmcu__getVersionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_zkmcu__getVersionResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "info", -1, &a->info, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct zkmcu__getVersionResponse * SOAP_FMAC4 soap_in_zkmcu__getVersionResponse(struct soap *soap, const char *tag, struct zkmcu__getVersionResponse *a, const char *type)
{
	size_t soap_flag_info = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct zkmcu__getVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_zkmcu__getVersionResponse, sizeof(struct zkmcu__getVersionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_zkmcu__getVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "info", &a->info, "xsd:string"))
				{	soap_flag_info--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct zkmcu__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_zkmcu__getVersionResponse, 0, sizeof(struct zkmcu__getVersionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_zkmcu__getVersionResponse(struct soap *soap, const struct zkmcu__getVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_zkmcu__getVersionResponse);
	if (soap_out_zkmcu__getVersionResponse(soap, tag?tag:"zkmcu:getVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__getVersionResponse * SOAP_FMAC4 soap_get_zkmcu__getVersionResponse(struct soap *soap, struct zkmcu__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_zkmcu__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct zkmcu__getVersionResponse * SOAP_FMAC2 soap_instantiate_zkmcu__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_zkmcu__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_zkmcu__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct zkmcu__getVersionResponse);
		if (size)
			*size = sizeof(struct zkmcu__getVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct zkmcu__getVersionResponse, n);
		if (size)
			*size = n * sizeof(struct zkmcu__getVersionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct zkmcu__getVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_zkmcu__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct zkmcu__getVersionResponse %p -> %p\n", q, p));
	*(struct zkmcu__getVersionResponse*)p = *(struct zkmcu__getVersionResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__KeyValueArray(struct soap *soap, struct zkmcu__KeyValueArray *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_zkmcu__KeyValueArray(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__KeyValueArray(struct soap *soap, const char *tag, int id, struct zkmcu__KeyValueArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_zkmcu__KeyValueArray);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__KeyValueArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__KeyValueArray ** SOAP_FMAC4 soap_in_PointerTozkmcu__KeyValueArray(struct soap *soap, const char *tag, struct zkmcu__KeyValueArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__KeyValueArray **)soap_malloc(soap, sizeof(struct zkmcu__KeyValueArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__KeyValueArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__KeyValueArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__KeyValueArray, sizeof(struct zkmcu__KeyValueArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__KeyValueArray(struct soap *soap, struct zkmcu__KeyValueArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__KeyValueArray);
	if (soap_out_PointerTozkmcu__KeyValueArray(soap, tag?tag:"zkmcu:KeyValueArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__KeyValueArray ** SOAP_FMAC4 soap_get_PointerTozkmcu__KeyValueArray(struct soap *soap, struct zkmcu__KeyValueArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__KeyValueArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__KeyValue(struct soap *soap, struct zkmcu__KeyValue *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_zkmcu__KeyValue))
		soap_serialize_zkmcu__KeyValue(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__KeyValue(struct soap *soap, const char *tag, int id, struct zkmcu__KeyValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_zkmcu__KeyValue);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__KeyValue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__KeyValue ** SOAP_FMAC4 soap_in_PointerTozkmcu__KeyValue(struct soap *soap, const char *tag, struct zkmcu__KeyValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__KeyValue **)soap_malloc(soap, sizeof(struct zkmcu__KeyValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__KeyValue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__KeyValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__KeyValue, sizeof(struct zkmcu__KeyValue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__KeyValue(struct soap *soap, struct zkmcu__KeyValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__KeyValue);
	if (soap_out_PointerTozkmcu__KeyValue(soap, tag?tag:"zkmcu:KeyValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__KeyValue ** SOAP_FMAC4 soap_get_PointerTozkmcu__KeyValue(struct soap *soap, struct zkmcu__KeyValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__KeyValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__AddStreamRequest(struct soap *soap, struct zkmcu__AddStreamRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_zkmcu__AddStreamRequest))
		soap_serialize_zkmcu__AddStreamRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__AddStreamRequest(struct soap *soap, const char *tag, int id, struct zkmcu__AddStreamRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_zkmcu__AddStreamRequest);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__AddStreamRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__AddStreamRequest ** SOAP_FMAC4 soap_in_PointerTozkmcu__AddStreamRequest(struct soap *soap, const char *tag, struct zkmcu__AddStreamRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__AddStreamRequest **)soap_malloc(soap, sizeof(struct zkmcu__AddStreamRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__AddStreamRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddStreamRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__AddStreamRequest, sizeof(struct zkmcu__AddStreamRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__AddStreamRequest(struct soap *soap, struct zkmcu__AddStreamRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__AddStreamRequest);
	if (soap_out_PointerTozkmcu__AddStreamRequest(soap, tag?tag:"zkmcu:AddStreamRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddStreamRequest ** SOAP_FMAC4 soap_get_PointerTozkmcu__AddStreamRequest(struct soap *soap, struct zkmcu__AddStreamRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__AddStreamRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__AddSinkRequest(struct soap *soap, struct zkmcu__AddSinkRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_zkmcu__AddSinkRequest))
		soap_serialize_zkmcu__AddSinkRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__AddSinkRequest(struct soap *soap, const char *tag, int id, struct zkmcu__AddSinkRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_zkmcu__AddSinkRequest);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__AddSinkRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__AddSinkRequest ** SOAP_FMAC4 soap_in_PointerTozkmcu__AddSinkRequest(struct soap *soap, const char *tag, struct zkmcu__AddSinkRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__AddSinkRequest **)soap_malloc(soap, sizeof(struct zkmcu__AddSinkRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__AddSinkRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddSinkRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__AddSinkRequest, sizeof(struct zkmcu__AddSinkRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__AddSinkRequest(struct soap *soap, struct zkmcu__AddSinkRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__AddSinkRequest);
	if (soap_out_PointerTozkmcu__AddSinkRequest(soap, tag?tag:"zkmcu:AddSinkRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddSinkRequest ** SOAP_FMAC4 soap_get_PointerTozkmcu__AddSinkRequest(struct soap *soap, struct zkmcu__AddSinkRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__AddSinkRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__AddSourceRequest(struct soap *soap, struct zkmcu__AddSourceRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_zkmcu__AddSourceRequest))
		soap_serialize_zkmcu__AddSourceRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__AddSourceRequest(struct soap *soap, const char *tag, int id, struct zkmcu__AddSourceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_zkmcu__AddSourceRequest);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__AddSourceRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__AddSourceRequest ** SOAP_FMAC4 soap_in_PointerTozkmcu__AddSourceRequest(struct soap *soap, const char *tag, struct zkmcu__AddSourceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__AddSourceRequest **)soap_malloc(soap, sizeof(struct zkmcu__AddSourceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__AddSourceRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__AddSourceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__AddSourceRequest, sizeof(struct zkmcu__AddSourceRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__AddSourceRequest(struct soap *soap, struct zkmcu__AddSourceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__AddSourceRequest);
	if (soap_out_PointerTozkmcu__AddSourceRequest(soap, tag?tag:"zkmcu:AddSourceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__AddSourceRequest ** SOAP_FMAC4 soap_get_PointerTozkmcu__AddSourceRequest(struct soap *soap, struct zkmcu__AddSourceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__AddSourceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__SinkInfoArray(struct soap *soap, struct zkmcu__SinkInfoArray *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_zkmcu__SinkInfoArray(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__SinkInfoArray(struct soap *soap, const char *tag, int id, struct zkmcu__SinkInfoArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_zkmcu__SinkInfoArray);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__SinkInfoArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__SinkInfoArray ** SOAP_FMAC4 soap_in_PointerTozkmcu__SinkInfoArray(struct soap *soap, const char *tag, struct zkmcu__SinkInfoArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__SinkInfoArray **)soap_malloc(soap, sizeof(struct zkmcu__SinkInfoArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__SinkInfoArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SinkInfoArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__SinkInfoArray, sizeof(struct zkmcu__SinkInfoArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__SinkInfoArray(struct soap *soap, struct zkmcu__SinkInfoArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__SinkInfoArray);
	if (soap_out_PointerTozkmcu__SinkInfoArray(soap, tag?tag:"zkmcu:SinkInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SinkInfoArray ** SOAP_FMAC4 soap_get_PointerTozkmcu__SinkInfoArray(struct soap *soap, struct zkmcu__SinkInfoArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__SinkInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__SourceInfoArray(struct soap *soap, struct zkmcu__SourceInfoArray *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_zkmcu__SourceInfoArray(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__SourceInfoArray(struct soap *soap, const char *tag, int id, struct zkmcu__SourceInfoArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_zkmcu__SourceInfoArray);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__SourceInfoArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__SourceInfoArray ** SOAP_FMAC4 soap_in_PointerTozkmcu__SourceInfoArray(struct soap *soap, const char *tag, struct zkmcu__SourceInfoArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__SourceInfoArray **)soap_malloc(soap, sizeof(struct zkmcu__SourceInfoArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__SourceInfoArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SourceInfoArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__SourceInfoArray, sizeof(struct zkmcu__SourceInfoArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__SourceInfoArray(struct soap *soap, struct zkmcu__SourceInfoArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__SourceInfoArray);
	if (soap_out_PointerTozkmcu__SourceInfoArray(soap, tag?tag:"zkmcu:SourceInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SourceInfoArray ** SOAP_FMAC4 soap_get_PointerTozkmcu__SourceInfoArray(struct soap *soap, struct zkmcu__SourceInfoArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__SourceInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__StreamInfoArray(struct soap *soap, struct zkmcu__StreamInfoArray *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_zkmcu__StreamInfoArray(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__StreamInfoArray(struct soap *soap, const char *tag, int id, struct zkmcu__StreamInfoArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_zkmcu__StreamInfoArray);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__StreamInfoArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__StreamInfoArray ** SOAP_FMAC4 soap_in_PointerTozkmcu__StreamInfoArray(struct soap *soap, const char *tag, struct zkmcu__StreamInfoArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__StreamInfoArray **)soap_malloc(soap, sizeof(struct zkmcu__StreamInfoArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__StreamInfoArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__StreamInfoArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__StreamInfoArray, sizeof(struct zkmcu__StreamInfoArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__StreamInfoArray(struct soap *soap, struct zkmcu__StreamInfoArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__StreamInfoArray);
	if (soap_out_PointerTozkmcu__StreamInfoArray(soap, tag?tag:"zkmcu:StreamInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__StreamInfoArray ** SOAP_FMAC4 soap_get_PointerTozkmcu__StreamInfoArray(struct soap *soap, struct zkmcu__StreamInfoArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__StreamInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__SinkInfo(struct soap *soap, struct zkmcu__SinkInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_zkmcu__SinkInfo))
		soap_serialize_zkmcu__SinkInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__SinkInfo(struct soap *soap, const char *tag, int id, struct zkmcu__SinkInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_zkmcu__SinkInfo);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__SinkInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__SinkInfo ** SOAP_FMAC4 soap_in_PointerTozkmcu__SinkInfo(struct soap *soap, const char *tag, struct zkmcu__SinkInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__SinkInfo **)soap_malloc(soap, sizeof(struct zkmcu__SinkInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__SinkInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SinkInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__SinkInfo, sizeof(struct zkmcu__SinkInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__SinkInfo(struct soap *soap, struct zkmcu__SinkInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__SinkInfo);
	if (soap_out_PointerTozkmcu__SinkInfo(soap, tag?tag:"zkmcu:SinkInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SinkInfo ** SOAP_FMAC4 soap_get_PointerTozkmcu__SinkInfo(struct soap *soap, struct zkmcu__SinkInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__SinkInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__SourceInfo(struct soap *soap, struct zkmcu__SourceInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_zkmcu__SourceInfo))
		soap_serialize_zkmcu__SourceInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__SourceInfo(struct soap *soap, const char *tag, int id, struct zkmcu__SourceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_zkmcu__SourceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__SourceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__SourceInfo ** SOAP_FMAC4 soap_in_PointerTozkmcu__SourceInfo(struct soap *soap, const char *tag, struct zkmcu__SourceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__SourceInfo **)soap_malloc(soap, sizeof(struct zkmcu__SourceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__SourceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__SourceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__SourceInfo, sizeof(struct zkmcu__SourceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__SourceInfo(struct soap *soap, struct zkmcu__SourceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__SourceInfo);
	if (soap_out_PointerTozkmcu__SourceInfo(soap, tag?tag:"zkmcu:SourceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__SourceInfo ** SOAP_FMAC4 soap_get_PointerTozkmcu__SourceInfo(struct soap *soap, struct zkmcu__SourceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__SourceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__StreamInfo(struct soap *soap, struct zkmcu__StreamInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_zkmcu__StreamInfo))
		soap_serialize_zkmcu__StreamInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__StreamInfo(struct soap *soap, const char *tag, int id, struct zkmcu__StreamInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_zkmcu__StreamInfo);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__StreamInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__StreamInfo ** SOAP_FMAC4 soap_in_PointerTozkmcu__StreamInfo(struct soap *soap, const char *tag, struct zkmcu__StreamInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__StreamInfo **)soap_malloc(soap, sizeof(struct zkmcu__StreamInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__StreamInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__StreamInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__StreamInfo, sizeof(struct zkmcu__StreamInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__StreamInfo(struct soap *soap, struct zkmcu__StreamInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__StreamInfo);
	if (soap_out_PointerTozkmcu__StreamInfo(soap, tag?tag:"zkmcu:StreamInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__StreamInfo ** SOAP_FMAC4 soap_get_PointerTozkmcu__StreamInfo(struct soap *soap, struct zkmcu__StreamInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__StreamInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTozkmcu__CreateConference(struct soap *soap, struct zkmcu__CreateConference *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_zkmcu__CreateConference))
		soap_serialize_zkmcu__CreateConference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTozkmcu__CreateConference(struct soap *soap, const char *tag, int id, struct zkmcu__CreateConference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_zkmcu__CreateConference);
	if (id < 0)
		return soap->error;
	return soap_out_zkmcu__CreateConference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct zkmcu__CreateConference ** SOAP_FMAC4 soap_in_PointerTozkmcu__CreateConference(struct soap *soap, const char *tag, struct zkmcu__CreateConference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct zkmcu__CreateConference **)soap_malloc(soap, sizeof(struct zkmcu__CreateConference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_zkmcu__CreateConference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct zkmcu__CreateConference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_zkmcu__CreateConference, sizeof(struct zkmcu__CreateConference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTozkmcu__CreateConference(struct soap *soap, struct zkmcu__CreateConference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTozkmcu__CreateConference);
	if (soap_out_PointerTozkmcu__CreateConference(soap, tag?tag:"zkmcu:CreateConference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct zkmcu__CreateConference ** SOAP_FMAC4 soap_get_PointerTozkmcu__CreateConference(struct soap *soap, struct zkmcu__CreateConference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTozkmcu__CreateConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
